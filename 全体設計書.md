貿易DX管理システム
詳細設計書
Version 2.1 - 実運用強化版


文書番号	DES-TRADE-DX-001
バージョン	1.0
作成日	2025年11月13日
最終更新日	2025年11月13日
作成者	開発チーム
レビュー者	
承認者	
ステータス	ドラフト
 
改訂履歴
バージョン	日付	変更内容	変更者	承認者
1.0	2025/11/13	初版作成	開発チーム	
2.0	2025/11/13	ファイル分割方式、自動バックアップ、変更履歴機能を追加	開発チーム	
2.1	2025/11/13	実運用リスク対策：30分同期、案件番号サーバー、死活監視、競合解決改善	開発チーム	
 
目次
1. 設計概要
  1.1 本文書の目的
  1.2 対象読者
  1.3 前提条件
  1.4 参照文書
2. システム構成
  2.1 アーキテクチャ
  2.2 技術スタック
  2.3 ディレクトリ構成
3. データベース設計
  3.1 論理設計
  3.2 物理設計（Excelシート）
  3.3 データ整合性
4. VBA設計
  4.1 モジュール構成
  4.2 機能詳細設計
  4.3 共通関数・定数
5. Python設計
  5.1 スクリプト構成
  5.2 機能詳細設計
6. 画面設計
  6.1 画面レイアウト詳細
  6.2 条件付き書式
7. 帳票設計
  7.1 Invoice設計
  7.2 Packing List設計
8. エラーハンドリング
  8.1 エラー分類
  8.2 エラー処理方針
9. セキュリティ設計
10. テスト設計
 
1. 設計概要
1.1 本文書の目的

本文書は、貿易DX管理システムの詳細設計書であり、以下を目的とする：
- 開発者が実装可能なレベルの詳細仕様を提供
- プログラム構造、処理フロー、データ構造を明確化
- コードレビューとテストの基準を定義
- 保守・改修時の参照ドキュメントとして機能

1.2 対象読者
•	VBA開発者（プログラマー）
•	Python開発者（スクリプト作成者）
•	テスト担当者
•	レビュー担当者
•	保守担当者
1.3 前提条件
項目	内容
開発環境	Microsoft Excel 2016以降（VBA有効）
OS	Windows 10 / 11
Python	Python 3.8以降（オプション機能用）
ライブラリ	pandas, openpyxl（Python使用時）
要件定義書	REQ-TRADE-DX-001 v1.0準拠
1.4 参照文書
•	要件定義書（REQ-TRADE-DX-001 v1.0）
•	Excel VBA リファレンス
•	Python pandas ドキュメント
 
2. システム構成
2.1 アーキテクチャ

本システムは3層アーキテクチャを採用：

【プレゼンテーション層】
- Excelワークシート（UI）
- ユーザーフォーム（ダイアログ）
- ボタン・コントロール

【ビジネスロジック層】
- VBAマクロ（Excel内蔵）
- Pythonスクリプト（外部実行）

【データ層】
- Excelワークシート（データストア）
- ローカルファイルシステム

2.2 技術スタック
レイヤー	技術	バージョン
UI	Microsoft Excel	2016以降
ビジネスロジック	VBA (Visual Basic for Applications)	7.1
ビジネスロジック	Python	3.8以降
データストア	Excel Workbook (.xlsm)	Office Open XML
ライブラリ	pandas, openpyxl	最新版
2.3 ディレクトリ構成

プロジェクトのディレクトリ構造：

trade_dx/
├── 案件管理台帳.xlsm          # メインファイル
│   ├── [VBAモジュール]
│   │   ├── Module1_CaseManagement      # 案件管理
│   │   ├── Module2_InvoiceGenerator    # Invoice生成
│   │   ├── Module3_PackingList         # Packing List生成
│   │   ├── Module4_Validation          # 入力チェック
│   │   ├── Module5_Utilities           # ユーティリティ
│   │   └── Module6_Constants           # 定数定義
│   │
│   └── [ワークシート]
│       ├── 案件一覧                    # メインデータ
│       ├── 顧客マスタ                  # 顧客情報
│       ├── 商品マスタ                  # 商品情報
│       └── 設定                        # システム設定
│
├── python/                            # Pythonスクリプト（オプション）
│   ├── backup.py                      # バックアップ
│   ├── monthly_report.py              # 月次レポート
│   ├── data_integration.py            # データ統合
│   └── utils.py                       # 共通関数
│
├── templates/                         # 帳票テンプレート
│   ├── Invoice_Template.xlsx
│   └── PackingList_Template.xlsx
│
├── backup/                            # バックアップフォルダ
│
└── output/                            # 出力ファイル
    ├── invoices/
    ├── packing_lists/
    └── reports/

 
3. データベース設計
3.1 論理設計
【エンティティ関連図（ER図）】

案件 (Case)
├─ 案件番号 [PK]
├─ 顧客コード [FK → 顧客]
├─ 商品コード [FK → 商品]
├─ 担当者
└─ その他属性

顧客 (Customer)
├─ 顧客コード [PK]
├─ 顧客名
└─ その他属性

商品 (Product)
├─ 商品コード [PK]
├─ 商品名
└─ その他属性

設定 (Config)
└─ キー・バリュー形式

3.2 物理設計（Excelシート）
シート1: 案件一覧
列	列名	データ型	桁数	必須	制約	備考
A	案件番号	String	12	○	YYYY-XX-NNN	PK
B	区分	String	2	○	リスト: 輸出,輸入	
C	顧客名	String	50	○		
D	仕入先	String	50	○		
E	商品名	String	100	○		
F	数量	Integer	10	○	≥0	
G	単位	String	10	○	リスト: kg,pcs,m3	
H	販売単価	Currency	15	○	≥0	小数点2桁
I	仕入単価	Currency	15	○	≥0	小数点2桁
J	売上額	Currency	15	-	計算式	=F*H
K	粗利額	Currency	15	-	計算式	=(F*H)-(F*I)
L	粗利率	Percentage	10	-	計算式	=K/J
M	船積予定日	Date	10	○	yyyy/mm/dd	
N	ステータス	String	10	○	リスト: 5段階	
O	担当者	String	20	○	リスト	設定から取得

【計算式詳細】
•	J列（売上額）: =F2*H2
•	K列（粗利額）: =(F2*H2)-(F2*I2)
•	L列（粗利率）: =IFERROR(K2/J2, 0)
 
シート2: 顧客マスタ
列	列名	データ型	桁数	必須	制約	備考
A	顧客コード	String	6	○	英数字	PK
B	顧客名	String	50	○		
C	顧客名（英語）	String	100	○		Invoice用
D	住所	String	200	-		
E	住所（英語）	String	300	-		Invoice用
F	電話番号	String	20	-		
G	担当者	String	30	-		
 
3.3 データ整合性
【参照整合性】
•	案件.顧客名は顧客マスタに存在する顧客名であること
•	案件.商品名は商品マスタに存在する商品名であること（推奨）
•	削除時：顧客マスタの削除前に、該当顧客の案件がないことを確認

【バリデーションルール】
•	必須項目：空白不可
•	数量・単価：0以上の数値
•	船積予定日：有効な日付形式
•	案件番号：書式チェック（正規表現: ^\d{4}-(EX|IM)-\d{3}$）
•	区分：リストから選択

【実装方法】
Excelのデータ入力規則（Data Validation）を使用：
•	B列（区分）: リスト = 輸出,輸入
•	G列（単位）: リスト = kg,pcs,m3,箱,本
•	N列（ステータス）: リスト = 引合,見積,受注,船積,完了
•	O列（担当者）: 設定シートの担当者リストを参照
•	F列（数量）: 整数 ≥ 0
•	H列・I列（単価）: 数値 ≥ 0
 
4. VBA設計
4.1 モジュール構成
モジュール名	種類	主要機能	推定行数
Module1_CaseManagement	標準モジュール	案件番号生成	80
Module2_InvoiceGenerator	標準モジュール	Invoice生成	150
Module3_PackingListGenerator	標準モジュール	Packing List生成	120
Module4_Validation	標準モジュール	入力検証	100
Module5_Utilities	標準モジュール	共通関数	60
Module6_Constants	標準モジュール	定数定義	40
ThisWorkbook	ワークブックモジュール	イベント処理	30

【総行数】: 約580行
 
4.2 機能詳細設計
F-007: 案件番号自動採番機能
【関数名】: GenerateCaseNumber
【モジュール】: Module1_CaseManagement
【呼び出し】: ボタンクリック or ユーザーフォーム

【関数シグネチャ】
Public Function GenerateCaseNumber(caseType As String) As String

【引数】
•	caseType (String): 案件区分 "輸出" または "輸入"

【戻り値】
•	String: 生成された案件番号（例: "2025-EX-001"）
•	Empty String: エラー時

【ローカル変数】
変数名	データ型	用途
currentYear	Integer	現在年（YYYY）
typeCode	String	区分コード（EX/IM）
maxSeq	Integer	既存の最大連番
newSeq	Integer	新規連番
caseNumber	String	生成された案件番号
ws	Worksheet	案件一覧シート
lastRow	Long	最終行番号
i	Long	ループカウンタ
 
【処理フロー】

1. 入力チェック
   ├ caseType が空白でないことを確認
   └ 不正な場合、エラーメッセージを表示して終了

2. 年の取得
   └ currentYear = Year(Date)

3. 区分コードの決定
   ├ IF caseType = "輸出" THEN typeCode = "EX"
   ├ ELSEIF caseType = "輸入" THEN typeCode = "IM"
   └ ELSE エラー終了

4. ワークシートの取得
   └ Set ws = ThisWorkbook.Worksheets("案件一覧")

5. 最大連番の取得
   ├ lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
   ├ FOR i = 2 To lastRow （ヘッダーを除く）
   │   ├ 案件番号を取得: tempNumber = ws.Cells(i, 1).Value
   │   ├ 同一年・同一区分かチェック
   │   └ 連番部分を抽出してmaxSeqを更新
   └ NEXT i

6. 新規連番の計算
   └ newSeq = maxSeq + 1

7. 連番オーバーフローチェック
   └ IF newSeq > 999 THEN エラー終了

8. 案件番号の生成
   └ caseNumber = CStr(currentYear) & "-" & typeCode & "-" & Format(newSeq, "000")

9. セルへの書き込み
   ├ targetRow = ActiveCell.Row
   ├ ws.Cells(targetRow, 1).Value = caseNumber
   └ ws.Cells(targetRow, 14).Value = Now()

10. 完了処理
    ├ MsgBox "案件番号 " & caseNumber & " が生成されました"
    └ Return caseNumber

 
【疑似コード】

Public Function GenerateCaseNumber(caseType As String) As String
    '------------------------------------------------
    ' 案件番号を自動生成する
    ' 引数: caseType - "輸出" または "輸入"
    ' 戻り値: 生成された案件番号（例: "2025-EX-001"）
    '------------------------------------------------
    
    Dim currentYear As Integer
    Dim typeCode As String
    Dim maxSeq As Integer
    Dim newSeq As Integer
    Dim caseNumber As String
    Dim ws As Worksheet
    Dim lastRow As Long
    Dim i As Long
    Dim tempNumber As String
    Dim tempSeq As Integer
    
    On Error GoTo ErrorHandler
    
    ' 1. 入力チェック
    If caseType = "" Then
        MsgBox "区分を選択してください", vbExclamation, "入力エラー"
        GenerateCaseNumber = ""
        Exit Function
    End If
    
    ' 2. 年の取得
    currentYear = Year(Date)
    
    ' 3. 区分コードの決定
    If caseType = "輸出" Then
        typeCode = "EX"
    ElseIf caseType = "輸入" Then
        typeCode = "IM"
    Else
        MsgBox "無効な区分です", vbCritical, "エラー"
        GenerateCaseNumber = ""
        Exit Function
    End If
    
    ' 4. ワークシートの取得
    Set ws = ThisWorkbook.Worksheets("案件一覧")
    
    ' 5. 最大連番の取得
    maxSeq = 0
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    
    For i = 2 To lastRow  ' 1行目はヘッダー
        tempNumber = ws.Cells(i, 1).Value
        
        ' 同一年・同一区分のみ処理
        If Left(tempNumber, 4) = CStr(currentYear) And _
           Mid(tempNumber, 6, 2) = typeCode Then
            
            ' 連番部分（右3桁）を取得
            tempSeq = CInt(Right(tempNumber, 3))
            
            ' 最大値を更新
            If tempSeq > maxSeq Then
                maxSeq = tempSeq
            End If
        End If
    Next i
    
    ' 6. 新規連番の計算
    newSeq = maxSeq + 1
    
    ' 7. 連番オーバーフローチェック
    If newSeq > 999 Then
        MsgBox "連番が上限（999）を超えました", vbCritical, "エラー"
        GenerateCaseNumber = ""
        Exit Function
    End If
    
    ' 8. 案件番号の生成
    caseNumber = CStr(currentYear) & "-" & typeCode & "-" & Format(newSeq, "000")
    
    ' 9. セルへの書き込み
    Dim targetRow As Long
    targetRow = ActiveCell.Row
    
    ws.Cells(targetRow, 1).Value = caseNumber       ' A列: 案件番号
    ws.Cells(targetRow, 14).Value = Now()           ' N列: 登録日時
    
    ' 10. 完了処理
    MsgBox "案件番号 " & caseNumber & " が生成されました", vbInformation, "完了"
    
    GenerateCaseNumber = caseNumber
    Exit Function
    
ErrorHandler:
    MsgBox "エラーが発生しました: " & Err.Description, vbCritical, "エラー"
    GenerateCaseNumber = ""
End Function

 
【呼び出し例】

' ボタンからの呼び出し
Private Sub btnGenerateCaseNumber_Click()
    Dim caseType As String
    Dim result As String
    
    ' 区分をユーザーに選択させる
    caseType = InputBox("区分を入力してください（輸出 または 輸入）", "案件番号生成")
    
    If caseType <> "" Then
        result = GenerateCaseNumber(caseType)
        
        If result <> "" Then
            ' 成功時の処理
            Debug.Print "生成された案件番号: " & result
        End If
    End If
End Sub


【テストケース】
No	テスト内容	入力	期待結果
1	正常系: 輸出案件	caseType = "輸出"	2025-EX-001
2	正常系: 輸入案件	caseType = "輸入"	2025-IM-001
3	正常系: 連番継続	既存: 2025-EX-005
caseType = "輸出"	2025-EX-006
4	異常系: 区分空白	caseType = ""	エラーメッセージ
5	異常系: 無効な区分	caseType = "その他"	エラーメッセージ
6	境界値: 連番999	既存: 2025-EX-999	エラーメッセージ
7	性能: 実行時間	案件数1000件	3秒以内
 
F-008: Invoice生成機能
【関数名】: GenerateInvoice
【モジュール】: Module2_InvoiceGenerator
【呼び出し】: ボタンクリック

【関数シグネチャ】
Public Sub GenerateInvoice(caseNumber As String)

【引数】
•	caseNumber (String): 対象案件の案件番号

【処理概要】

選択された案件情報を基に、Commercial Invoiceを新規シートとして生成する。
テンプレートを使用せず、VBAコードで直接セルに値を書き込む方式。


【処理フロー】

1. 案件情報の取得
   ├ 案件一覧シートから案件番号で検索
   ├ 該当行のデータを全て取得
   └ 存在チェック

2. 顧客情報の取得
   ├ 顧客マスタシートから顧客名で検索
   └ 英語名・住所を取得

3. 自社情報の取得
   └ 設定シートから自社情報を取得

4. 新規シートの作成
   ├ シート名: "Invoice_" & 案件番号
   ├ 既存の同名シートがあれば削除確認
   └ シートを作成

5. Invoiceレイアウトの構築
   ├ ヘッダー部（タイトル、Invoice No、Date）
   ├ Shipper情報（自社）
   ├ Consignee情報（顧客）
   ├ 明細部（Description, Qty, Unit Price, Amount）
   └ 合計金額

6. データの書き込み
   ├ 各セルに値を設定
   ├ 書式設定（フォント、罫線、配置）
   └ 印刷設定

7. PDF出力（オプション）
   └ ExportAsFixedFormat メソッド

8. 完了メッセージ
   └ 生成されたシート名を表示

 
【レイアウト設計】
セル	内容	書式	値の取得元
A1:F1	COMMERCIAL INVOICE	Arial 16pt Bold
Center	固定
A3	Invoice No:	Arial 11pt	固定
B3	[案件番号]	Arial 11pt Bold	案件データ
D3	Date:	Arial 11pt	固定
E3	[発行日]	Arial 11pt	Date関数
A5	Shipper:	Arial 11pt Bold	固定
A6:B8	[自社情報]	Arial 10pt	設定シート
D5	Consignee:	Arial 11pt Bold	固定
D6:F8	[顧客情報]	Arial 10pt	顧客マスタ
A10:F10	ヘッダー行	Arial 11pt Bold
罫線あり	固定
A11:F11	明細行	Arial 10pt
罫線あり	案件データ
E13	Total:	Arial 11pt Bold	固定
F13	[合計金額]	Arial 11pt Bold
通貨書式	計算
			
			
 
【疑似コード（抜粋）】

Public Sub GenerateInvoice(caseNumber As String)
    Dim wsCase As Worksheet
    Dim wsCustomer As Worksheet
    Dim wsConfig As Worksheet
    Dim wsInvoice As Worksheet
    Dim caseRow As Long
    Dim customerRow As Long
    
    On Error GoTo ErrorHandler
    
    ' ワークシート取得
    Set wsCase = ThisWorkbook.Worksheets("案件一覧")
    Set wsCustomer = ThisWorkbook.Worksheets("顧客マスタ")
    Set wsConfig = ThisWorkbook.Worksheets("設定")
    
    ' 案件情報の検索
    caseRow = FindCaseRow(wsCase, caseNumber)
    If caseRow = 0 Then
        MsgBox "案件番号が見つかりません", vbCritical
        Exit Sub
    End If
    
    ' 案件データの取得
    Dim customerName As String
    Dim productName As String
    Dim quantity As Double
    Dim unitPrice As Double
    Dim totalAmount As Double
    
    customerName = wsCase.Cells(caseRow, 3).Value      ' C列: 顧客名
    productName = wsCase.Cells(caseRow, 5).Value       ' E列: 商品名
    quantity = wsCase.Cells(caseRow, 6).Value          ' F列: 数量
    unitPrice = wsCase.Cells(caseRow, 8).Value         ' H列: 販売単価
    totalAmount = quantity * unitPrice
    
    ' 顧客情報の取得
    customerRow = FindCustomerRow(wsCustomer, customerName)
    Dim customerNameEn As String
    Dim customerAddress As String
    
    If customerRow > 0 Then
        customerNameEn = wsCustomer.Cells(customerRow, 3).Value  ' C列: 顧客名（英語）
        customerAddress = wsCustomer.Cells(customerRow, 5).Value ' E列: 住所（英語）
    Else
        customerNameEn = customerName  ' 英語名がない場合は日本語名を使用
        customerAddress = ""
    End If
    
    ' 自社情報の取得
    Dim companyNameEn As String
    Dim companyAddress As String
    
    companyNameEn = GetConfigValue(wsConfig, "自社名（英語）")
    companyAddress = GetConfigValue(wsConfig, "自社住所（英語）")
    
    ' 新規シートの作成
    Dim sheetName As String
    sheetName = "Invoice_" & caseNumber
    
    ' 既存シートの削除確認
    On Error Resume Next
    Application.DisplayAlerts = False
    ThisWorkbook.Worksheets(sheetName).Delete
    Application.DisplayAlerts = True
    On Error GoTo ErrorHandler
    
    ' 新規シート作成
    Set wsInvoice = ThisWorkbook.Worksheets.Add(After:=ThisWorkbook.Worksheets(ThisWorkbook.Worksheets.Count))
    wsInvoice.Name = sheetName
    
    ' レイアウト構築
    With wsInvoice
        ' ヘッダー
        .Range("A1:F1").Merge
        .Range("A1").Value = "COMMERCIAL INVOICE"
        .Range("A1").Font.Name = "Arial"
        .Range("A1").Font.Size = 16
        .Range("A1").Font.Bold = True
        .Range("A1").HorizontalAlignment = xlCenter
        
        ' Invoice番号と日付
        .Range("A3").Value = "Invoice No:"
        .Range("B3").Value = caseNumber
        .Range("B3").Font.Bold = True
        .Range("D3").Value = "Date:"
        .Range("E3").Value = Format(Date, "yyyy/mm/dd")
        
        ' Shipper（自社）
        .Range("A5").Value = "Shipper:"
        .Range("A5").Font.Bold = True
        .Range("A6").Value = companyNameEn
        .Range("A7").Value = companyAddress
        
        ' Consignee（顧客）
        .Range("D5").Value = "Consignee:"
        .Range("D5").Font.Bold = True
        .Range("D6").Value = customerNameEn
        .Range("D7").Value = customerAddress
        
        ' 明細ヘッダー
        .Range("A10").Value = "Description"
        .Range("C10").Value = "Quantity"
        .Range("D10").Value = "Unit Price"
        .Range("F10").Value = "Amount"
        .Range("A10:F10").Font.Bold = True
        .Range("A10:F10").Borders(xlEdgeBottom).Weight = xlMedium
        
        ' 明細
        .Range("A11").Value = productName
        .Range("C11").Value = quantity
        .Range("D11").Value = unitPrice
        .Range("D11").NumberFormat = "#,##0.00"
        .Range("F11").Value = totalAmount
        .Range("F11").NumberFormat = "#,##0.00"
        
        ' 合計
        .Range("E13").Value = "Total:"
        .Range("E13").Font.Bold = True
        .Range("F13").Value = totalAmount
        .Range("F13").NumberFormat = "#,##0.00"
        .Range("F13").Font.Bold = True
        .Range("F13").Borders(xlEdgeTop).Weight = xlMedium
        
        ' 列幅調整
        .Columns("A:B").ColumnWidth = 20
        .Columns("C").ColumnWidth = 12
        .Columns("D").ColumnWidth = 15
        .Columns("F").ColumnWidth = 15
        
        ' 印刷設定
        .PageSetup.Orientation = xlPortrait
        .PageSetup.PaperSize = xlPaperA4
        .PageSetup.PrintArea = "A1:F15"
    End With
    
    ' 完了メッセージ
    MsgBox "Invoice " & caseNumber & " を生成しました" & vbCrLf & _
           "シート名: " & sheetName, vbInformation, "完了"
    
    ' Invoiceシートをアクティブに
    wsInvoice.Activate
    
    Exit Sub
    
ErrorHandler:
    MsgBox "Invoiceの生成中にエラーが発生しました: " & Err.Description, _
           vbCritical, "エラー"
End Sub

' ヘルパー関数: 案件行を検索
Private Function FindCaseRow(ws As Worksheet, caseNumber As String) As Long
    Dim lastRow As Long
    Dim i As Long
    
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    
    For i = 2 To lastRow
        If ws.Cells(i, 1).Value = caseNumber Then
            FindCaseRow = i
            Exit Function
        End If
    Next i
    
    FindCaseRow = 0  ' 見つからない
End Function

' ヘルパー関数: 顧客行を検索
Private Function FindCustomerRow(ws As Worksheet, customerName As String) As Long
    Dim lastRow As Long
    Dim i As Long
    
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    
    For i = 2 To lastRow
        If ws.Cells(i, 2).Value = customerName Then
            FindCustomerRow = i
            Exit Function
        End If
    Next i
    
    FindCustomerRow = 0
End Function

' ヘルパー関数: 設定値を取得
Private Function GetConfigValue(ws As Worksheet, key As String) As String
    Dim lastRow As Long
    Dim i As Long
    
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    
    For i = 2 To lastRow
        If ws.Cells(i, 1).Value = key Then
            GetConfigValue = ws.Cells(i, 2).Value
            Exit Function
        End If
    Next i
    
    GetConfigValue = ""
End Function

 
4.3 共通関数・定数
【Module5_Utilities: 共通関数】
関数名	機能	戻り値
IsValidCaseNumber	案件番号の書式チェック	Boolean
GetWorksheetSafely	シートを安全に取得	Worksheet
ShowMessage	メッセージ表示（ログ付き）	なし
FormatCurrency	通貨書式の統一	String
GetCurrentUser	現在のユーザー名取得	String
LogError	エラーログの記録	なし
BackupWorkbook	ワークブックのバックアップ	Boolean

【Module6_Constants: 定数定義】

' シート名定数
Public Const SHEET_CASE_LIST As String = "案件一覧"
Public Const SHEET_CUSTOMER As String = "顧客マスタ"
Public Const SHEET_PRODUCT As String = "商品マスタ"
Public Const SHEET_CONFIG As String = "設定"

' 列番号定数（案件一覧シート）
Public Const COL_CASE_NUMBER As Integer = 1        ' A列
Public Const COL_CASE_TYPE As Integer = 2          ' B列
Public Const COL_CUSTOMER_NAME As Integer = 3      ' C列
Public Const COL_SUPPLIER As Integer = 4           ' D列
Public Const COL_PRODUCT_NAME As Integer = 5       ' E列
Public Const COL_QUANTITY As Integer = 6           ' F列
Public Const COL_UNIT As Integer = 7               ' G列
Public Const COL_SELLING_PRICE As Integer = 8      ' H列
Public Const COL_BUYING_PRICE As Integer = 9       ' I列
Public Const COL_SALES_AMOUNT As Integer = 10      ' J列
Public Const COL_PROFIT_AMOUNT As Integer = 11     ' K列
Public Const COL_PROFIT_RATE As Integer = 12       ' L列
Public Const COL_SHIP_DATE As Integer = 13         ' M列
Public Const COL_STATUS As Integer = 14            ' N列
Public Const COL_PERSON_IN_CHARGE As Integer = 15  ' O列

' ステータス定数
Public Const STATUS_INQUIRY As String = "引合"
Public Const STATUS_QUOTATION As String = "見積"
Public Const STATUS_ORDER As String = "受注"
Public Const STATUS_SHIPMENT As String = "船積"
Public Const STATUS_COMPLETED As String = "完了"

' メッセージ定数
Public Const MSG_SUCCESS As String = "処理が正常に完了しました"
Public Const MSG_ERROR_PREFIX As String = "エラーが発生しました: "
Public Const MSG_CONFIRM_DELETE As String = "削除してもよろしいですか？"

' バリデーション定数
Public Const CASE_NUMBER_PATTERN As String = "^\d{4}-(EX|IM)-\d{3}$"
Public Const MAX_SEQUENCE As Integer = 999

 
5. Python設計
5.1 スクリプト構成
ファイル名	機能	主要関数	推定行数
backup.py	バックアップ機能	backup_excel(), schedule_backup()	80
monthly_report.py	月次レポート生成	generate_report(), export_excel()	150
data_integration.py	データ統合	integrate_data(), clean_data()	120
utils.py	共通ユーティリティ	各種ヘルパー関数	60
config.py	設定管理	設定値の読み書き	40

5.2 機能詳細設計
F-011: 月次レポート生成機能
【ファイル名】: monthly_report.py
【主要関数】: generate_monthly_report()

【関数シグネチャ】
def generate_monthly_report(file_path: str, output_dir: str = "./output") -> dict:

【引数】
•	file_path (str): 案件管理台帳のファイルパス
•	output_dir (str): レポート出力先ディレクトリ（デフォルト: ./output）

【戻り値】
•	dict: レポート結果を含む辞書
•	  - success (bool): 成功/失敗
•	  - output_file (str): 出力ファイルパス
•	  - summary (dict): 集計結果

【処理フロー】

1. Excelファイルの読み込み
   ├ pandasでExcelファイルを読み込み
   ├ 案件一覧シートを取得
   └ データ型の確認

2. データの前処理
   ├ 欠損値の処理
   ├ 日付型への変換
   └ 数値型への変換

3. 対象月の抽出
   ├ 船積予定日から対象月のデータを抽出
   └ フィルタリング

4. 集計処理
   ├ 総案件数
   ├ 区分別案件数（輸出/輸入）
   ├ ステータス別案件数
   ├ 完了率
   ├ 総売上額・総粗利額
   ├ 平均粗利率
   ├ 顧客別売上TOP5
   └ 商品別売上TOP5

5. レポートの作成
   ├ サマリーシート作成
   ├ 詳細データシート作成
   └ グラフ作成（オプション）

6. Excelファイルへの出力
   ├ openpyxlでExcelファイルを作成
   ├ 書式設定
   └ 保存

7. 結果の返却
   └ 辞書形式で結果を返す

 
【サンプルコード】

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
月次レポート生成スクリプト

このスクリプトは案件管理台帳から月次レポートを生成します。
"""

import pandas as pd
from datetime import datetime
from pathlib import Path
import openpyxl
from openpyxl.styles import Font, PatternFill, Alignment


def generate_monthly_report(file_path: str, output_dir: str = "./output") -> dict:
    """
    月次レポートを生成する
    
    Args:
        file_path (str): 案件管理台帳のパス
        output_dir (str): 出力先ディレクトリ
        
    Returns:
        dict: 処理結果
            - success (bool): 成功/失敗
            - output_file (str): 出力ファイルパス
            - summary (dict): 集計サマリー
    """
    
    try:
        # 1. Excelファイルの読み込み
        df = pd.read_excel(file_path, sheet_name='案件一覧')
        
        # 2. データの前処理
        df['船積予定日'] = pd.to_datetime(df['船積予定日'], errors='coerce')
        df['数量'] = pd.to_numeric(df['数量'], errors='coerce')
        df['販売単価'] = pd.to_numeric(df['販売単価'], errors='coerce')
        df['仕入単価'] = pd.to_numeric(df['仕入単価'], errors='coerce')
        
        # 売上額・粗利額・粗利率の計算
        df['売上額'] = df['数量'] * df['販売単価']
        df['粗利額'] = (df['数量'] * df['販売単価']) - (df['数量'] * df['仕入単価'])
        df['粗利率'] = df['粗利額'] / df['売上額']
        
        # 3. 対象月の抽出（当月）
        current_month = datetime.now().replace(day=1)
        next_month = (current_month + pd.DateOffset(months=1))
        
        df_month = df[
            (df['船積予定日'] >= current_month) & 
            (df['船積予定日'] < next_month)
        ]
        
        # 4. 集計処理
        summary = {
            '対象年月': current_month.strftime('%Y年%m月'),
            '総案件数': len(df_month),
            '輸出案件数': len(df_month[df_month['区分'] == '輸出']),
            '輸入案件数': len(df_month[df_month['区分'] == '輸入']),
            '完了案件数': len(df_month[df_month['ステータス'] == '完了']),
            '完了率': f"{len(df_month[df_month['ステータス'] == '完了']) / len(df_month) * 100:.1f}%" if len(df_month) > 0 else "0%",
            '総売上額': f"¥{df_month['売上額'].sum():,.0f}",
            '総粗利額': f"¥{df_month['粗利額'].sum():,.0f}",
            '平均粗利率': f"{df_month['粗利率'].mean() * 100:.1f}%" if len(df_month) > 0 else "0%",
        }
        
        # 顧客別売上TOP5
        customer_sales = df_month.groupby('顧客名')['売上額'].sum().sort_values(ascending=False).head(5)
        
        # 商品別売上TOP5
        product_sales = df_month.groupby('商品名')['売上額'].sum().sort_values(ascending=False).head(5)
        
        # 5. & 6. レポートの作成とExcel出力
        output_file = Path(output_dir) / f"月次レポート_{current_month.strftime('%Y%m')}.xlsx"
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
            # サマリーシート
            summary_df = pd.DataFrame([summary]).T
            summary_df.columns = ['値']
            summary_df.to_excel(writer, sheet_name='サマリー')
            
            # 顧客別売上
            customer_sales_df = pd.DataFrame(customer_sales)
            customer_sales_df.to_excel(writer, sheet_name='顧客別売上')
            
            # 商品別売上
            product_sales_df = pd.DataFrame(product_sales)
            product_sales_df.to_excel(writer, sheet_name='商品別売上')
            
            # 詳細データ
            df_month.to_excel(writer, sheet_name='案件詳細', index=False)
        
        # 書式設定（openpyxl使用）
        wb = openpyxl.load_workbook(output_file)
        ws_summary = wb['サマリー']
        
        # ヘッダー書式
        header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
        header_font = Font(color="FFFFFF", bold=True)
        
        for cell in ws_summary[1]:
            cell.fill = header_fill
            cell.font = header_font
            cell.alignment = Alignment(horizontal="center")
        
        wb.save(output_file)
        
        # 7. 結果の返却
        return {
            'success': True,
            'output_file': str(output_file),
            'summary': summary
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': str(e),
            'summary': {}
        }


def main():
    """メイン処理"""
    # 設定
    file_path = "案件管理台帳.xlsm"
    output_dir = "./output"
    
    # レポート生成
    result = generate_monthly_report(file_path, output_dir)
    
    if result['success']:
        print("=" * 60)
        print("  月次レポート生成完了")
        print("=" * 60)
        print(f"\n出力ファイル: {result['output_file']}")
        print("\n【サマリー】")
        for key, value in result['summary'].items():
            print(f"  {key}: {value}")
        print("=" * 60)
    else:
        print(f"エラー: {result.get('error', '不明なエラー')}")


if __name__ == "__main__":
    main()

 
F-013: バックアップ機能
【ファイル名】: backup.py

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
バックアップスクリプト

案件管理台帳を自動でバックアップします。
"""

import shutil
from datetime import datetime
from pathlib import Path


def backup_excel(source_file: str, backup_dir: str = "./backup") -> dict:
    """
    Excelファイルをバックアップする
    
    Args:
        source_file (str): バックアップ元ファイル
        backup_dir (str): バックアップ先ディレクトリ
        
    Returns:
        dict: 処理結果
    """
    
    try:
        # バックアップディレクトリの作成
        backup_path = Path(backup_dir)
        backup_path.mkdir(parents=True, exist_ok=True)
        
        # バックアップファイル名（日時付き）
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        source_path = Path(source_file)
        backup_file = backup_path / f"{source_path.stem}_{timestamp}{source_path.suffix}"
        
        # ファイルコピー
        shutil.copy2(source_file, backup_file)
        
        # 古いバックアップの削除（30日以上前）
        cleanup_old_backups(backup_path, days=30)
        
        return {
            'success': True,
            'backup_file': str(backup_file),
            'timestamp': timestamp
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': str(e)
        }


def cleanup_old_backups(backup_dir: Path, days: int = 30):
    """
    古いバックアップファイルを削除
    
    Args:
        backup_dir (Path): バックアップディレクトリ
        days (int): 保持日数
    """
    cutoff_date = datetime.now().timestamp() - (days * 86400)
    
    for file in backup_dir.glob("*"):
        if file.is_file() and file.stat().st_mtime < cutoff_date:
            file.unlink()
            print(f"削除: {file.name}")


def main():
    """メイン処理"""
    result = backup_excel("案件管理台帳.xlsm", "./backup")
    
    if result['success']:
        print("バックアップ完了")
        print(f"ファイル: {result['backup_file']}")
    else:
        print(f"エラー: {result.get('error', '不明なエラー')}")


if __name__ == "__main__":
    main()

 
8. エラーハンドリング
8.1 エラー分類
エラー分類	原因例	対処方法	優先度
入力エラー	必須項目未入力
不正なデータ型	バリデーションで防止
エラーメッセージ表示	高
データエラー	案件番号重複
参照先不在	存在チェック
ユーザーに確認	高
システムエラー	ファイル破損
メモリ不足	バックアップから復元
ファイル再起動	中
権限エラー	書き込み権限なし
ファイルロック	権限確認
他ユーザーの終了待ち	中
ネットワークエラー	ネットワーク切断
サーバー接続失敗	オフライン動作
再接続	低
計算エラー	ゼロ除算
オーバーフロー	条件分岐で回避
デフォルト値設定	中
外部連携エラー	API接続失敗
タイムアウト	リトライ処理
フォールバック	低
8.2 エラー処理方針
【VBAのエラー処理パターン】

Sub SampleFunction()
    On Error GoTo ErrorHandler
    
    ' 処理本体
    ' ...
    
    Exit Sub
    
ErrorHandler:
    Select Case Err.Number
        Case 9  ' 添字が有効範囲にありません
            MsgBox "データが見つかりません", vbExclamation
            
        Case 13  ' 型が一致しません
            MsgBox "データ型が正しくありません", vbExclamation
            
        Case Else
            MsgBox "エラーが発生しました: " & Err.Description, vbCritical
            
            ' ログ記録
            Call LogError(Err.Number, Err.Description, "SampleFunction")
    End Select
    
    ' クリーンアップ処理
    ' ...
End Sub


【Pythonのエラー処理パターン】

def sample_function():
    try:
        # 処理本体
        pass
        
    except FileNotFoundError as e:
        print(f"ファイルが見つかりません: {e}")
        return {'success': False, 'error': str(e)}
        
    except pd.errors.EmptyDataError as e:
        print(f"データが空です: {e}")
        return {'success': False, 'error': str(e)}
        
    except Exception as e:
        print(f"予期しないエラー: {e}")
        # ログ記録
        import traceback
        traceback.print_exc()
        return {'success': False, 'error': str(e)}
        
    finally:
        # クリーンアップ処理
        pass

 
9. セキュリティ設計
【実装するセキュリティ対策】
•	Excelファイルのパスワード保護
•	- 開封パスワードの設定
•	- 書き込みパスワードの設定（オプション）

•	VBAプロジェクトの保護
•	- VBAコードへのパスワード設定
•	- VBAプロジェクトのロック

•	アクセス権限管理
•	- 共有フォルダのアクセス権限
•	- Read/Write権限の分離

•	データバックアップ
•	- 自動バックアップの実施
•	- バックアップファイルの暗号化（オプション）

•	監査ログ
•	- 重要操作のログ記録
•	- エラーログの保存

【パスワード設定方法】

' Excelファイルにパスワードを設定
Sub SetFilePassword()
    Dim filePath As String
    Dim password As String
    
    filePath = ThisWorkbook.FullName
    password = "YourSecurePassword"
    
    ' 現在のワークブックを保存してパスワード設定
    ThisWorkbook.SaveAs _
        Filename:=filePath, _
        Password:=password, _
        WriteResPassword:=password
        
    MsgBox "パスワードを設定しました", vbInformation
End Sub

 
10. テスト設計
10.1 テスト戦略
【テストレベル】
•	単体テスト（Unit Test）
•	- 各VBA関数の動作確認
•	- Python関数の動作確認
•	- テスト担当: 開発者

•	結合テスト（Integration Test）
•	- モジュール間の連携確認
•	- データフローの確認
•	- テスト担当: 開発リーダー

•	システムテスト（System Test）
•	- 要件定義書との整合性確認
•	- 業務フローに沿った確認
•	- テスト担当: テスト担当者

•	受け入れテスト（UAT: User Acceptance Test）
•	- 実際のユーザーによる確認
•	- 実データでの動作確認
•	- テスト担当: エンドユーザー
10.2 テスト項目一覧
テストID	機能ID	テスト項目	テスト種別	優先度
T-001	F-007	案件番号生成_正常系	単体	高
T-002	F-007	案件番号生成_異常系	単体	高
T-003	F-008	Invoice生成_正常系	単体	高
T-004	F-008	Invoice生成_データ不在	単体	中
T-005	F-011	月次レポート生成	単体	中
T-006	F-001-005	案件登録～更新フロー	結合	高
T-007	F-008-009	帳票生成連携	結合	中
T-008	全機能	実業務シナリオ	システム	高
T-009	全機能	性能テスト	システム	中
T-010	全機能	ユーザー受け入れ	UAT	高
 
10.3 テストケース詳細（サンプル）
T-001: 案件番号生成_正常系
項目	内容
テストID	T-001
機能ID	F-007
テスト項目	案件番号生成_正常系
前提条件	・案件一覧シートが存在する
・2025年の輸出案件が5件存在（001-005）
テストデータ	区分: 輸出
実行手順	1. 案件番号生成ボタンをクリック
2. 区分に「輸出」を入力
3. OKをクリック
期待結果	・案件番号「2025-EX-006」が生成される
・A列に案件番号が入力される
・N列に登録日時が入力される
・完了メッセージが表示される
確認方法	・A列のセル値を目視確認
・N列の日時を確認
・メッセージ内容を確認
判定基準	期待結果が全て満たされること
実行日	
実行者	
結果	□ Pass  □ Fail
 
T-002: 案件番号生成_異常系
項目	内容
テストID	T-002
機能ID	F-007
テスト項目	案件番号生成_異常系（区分未入力）
前提条件	・案件一覧シートが存在する
テストデータ	区分: （空白）
実行手順	1. 案件番号生成ボタンをクリック
2. 区分を入力せずにOKをクリック
期待結果	・エラーメッセージ「区分を選択してください」が表示される
・案件番号は生成されない
・セルに値が入力されない
確認方法	・エラーメッセージの内容を確認
・セルが空白のままであることを確認
判定基準	エラーメッセージが正しく表示されること
実行日	
実行者	
結果	□ Pass  □ Fail
 
10.4 性能テスト
テスト項目	測定対象	目標値	測定方法
ファイル起動時間	案件数500件のファイル	5秒以内	ストップウォッチ
検索応答時間	全件検索	3秒以内	VBAタイマー
マクロ実行時間	案件番号生成	3秒以内	VBAタイマー
Invoice生成時間	1件のInvoice	10秒以内	VBAタイマー
月次レポート生成	案件数1000件	30秒以内	Pythonタイマー
 
付録A: 用語・略語集
用語・略語	説明
VBA	Visual Basic for Applications - Excelマクロの開発言語
pandas	Pythonのデータ分析ライブラリ
openpyxl	PythonでExcelファイルを操作するライブラリ
PK	Primary Key - 主キー（一意識別子）
FK	Foreign Key - 外部キー（参照キー）
ER図	Entity-Relationship Diagram - エンティティ関連図
UAT	User Acceptance Test - ユーザー受け入れテスト
API	Application Programming Interface - アプリケーション間の接続仕様
CSV	Comma-Separated Values - カンマ区切りテキスト
PDF	Portable Document Format - 文書フォーマット
UTC	Coordinated Universal Time - 協定世界時
CRUD	Create, Read, Update, Delete - データ操作の4基本機能
MVC	Model-View-Controller - アーキテクチャパターン
DRY	Don't Repeat Yourself - コード重複を避ける原則
KISS	Keep It Simple, Stupid - シンプルさを保つ原則
 
付録B: コーディング規約
【VBAコーディング規約】
•	変数名
•	- キャメルケース使用（例: caseNumber）
•	- 意味のある名前をつける
•	- 型接頭辞は使用しない（Hungarian記法は避ける）

•	定数名
•	- 全て大文字、アンダースコア区切り（例: MAX_SEQUENCE）
•	- Const キーワードで宣言

•	関数・サブルーチン名
•	- パスカルケース使用（例: GenerateCaseNumber）
•	- 動詞で始める（例: Get, Set, Calculate, Generate）

•	コメント
•	- 関数の先頭に機能説明を記載
•	- 複雑なロジックには行コメントを追加
•	- 日本語でOK

•	インデント
•	- 4スペース（タブは使用しない）
•	- If, For, With 等はインデント

•	エラー処理
•	- 全ての Public 関数にエラーハンドリングを実装
•	- On Error GoTo ErrorHandler パターンを使用

【Pythonコーディング規約】
•	変数名・関数名
•	- スネークケース使用（例: case_number）
•	- 意味のある名前をつける

•	定数名
•	- 全て大文字、アンダースコア区切り（例: MAX_SEQUENCE）

•	インデント
•	- 4スペース（PEP 8準拠）

•	コメント
•	- 関数にdocstringを記載
•	- Google Style Docstring形式

•	インポート
•	- 標準ライブラリ → サードパーティ → ローカルの順
•	- 1行に1つのインポート

•	型ヒント
•	- 関数の引数と戻り値に型ヒントを付ける
•	- Python 3.8以降の型ヒントを使用
 
付録C: 変更管理
【バージョン管理方針】
•	メジャーバージョン（x.0.0）: 大規模な機能追加・変更
•	マイナーバージョン（1.x.0）: 機能追加・改善
•	パッチバージョン（1.0.x）: バグ修正

【変更管理プロセス】
•	変更要求の提出
•	- 変更内容、理由、影響範囲を記載

•	影響分析
•	- 既存機能への影響を確認
•	- テスト範囲を決定

•	承認
•	- 変更管理委員会で承認

•	実装
•	- 詳細設計書を更新
•	- コーディング

•	テスト
•	- 単体テスト
•	- 回帰テスト

•	リリース
•	- バージョン番号を更新
•	- リリースノートを作成
 
付録D: 参考資料
【技術ドキュメント】
•	Microsoft Excel VBA リファレンス
https://learn.microsoft.com/ja-jp/office/vba/api/overview/excel

•	Python 公式ドキュメント
https://docs.python.org/ja/3/

•	pandas ドキュメント
https://pandas.pydata.org/docs/

•	openpyxl ドキュメント
https://openpyxl.readthedocs.io/

【関連ドキュメント】
•	要件定義書（REQ-TRADE-DX-001 v1.0）
•	操作マニュアル（別冊）
•	テスト仕様書（別冊）
 
承認
役割	氏名	承認日	署名
設計責任者			
開発リーダー			
レビュー担当者			
承認者			
 



以上


本詳細設計書に関するお問い合わせ先:
開発チーム
 
2.4 ファイル分割アーキテクチャ（V2.0新規）

【概要】
複数ユーザーの同時作業を可能にするため、ファイル分割方式を採用する。
各ユーザーは個人専用のファイルで作業し、1日1回データを統合する。

2.4.1 ファイル構成

共有フォルダ/
├── master/
│   └── 案件管理台帳_マスター.xlsm      【読み取り専用】統合後の最新データ
│
├── work/
│   ├── 案件管理台帳_山田.xlsm          【読み書き可】山田さん専用
│   ├── 案件管理台帳_鈴木.xlsm          【読み書き可】鈴木さん専用
│   ├── 案件管理台帳_佐藤.xlsm          【読み書き可】佐藤さん専用
│   └── 案件管理台帳_田中.xlsm          【読み書き可】田中さん専用
│
├── backup/
│   ├── master_20251113_090000.xlsm     【自動バックアップ】
│   ├── master_20251112_180000.xlsm
│   └── ...（30日分保持）
│
└── scripts/
    ├── distribute_data.py               【データ配布】朝実行
    ├── integrate_data.py                【データ統合】夕方実行
    ├── backup_master.py                 【バックアップ】自動実行
    └── config.json                      【設定ファイル】

2.4.2 運用フロー
【1日のワークフロー】
時刻	処理	実行者	内容
08:30	データ配布	Pythonスクリプト
（自動実行）	マスターから各個人ファイルへ
最新データを配布
09:00-17:00	日常業務	各担当者	各自の個人ファイルで
案件登録・更新・削除
17:30	データ統合	Pythonスクリプト
（自動実行）	全個人ファイルのデータを
マスターに統合
17:35	バックアップ	Pythonスクリプト
（自動実行）	マスターファイルを
タイムスタンプ付きで保存
17:40	整合性チェック	Pythonスクリプト
（自動実行）	重複・不整合をチェック
エラーがあればメール通知
翌朝08:30	データ配布	Pythonスクリプト
（自動実行）	最新マスターを各個人ファイルへ
 
2.4.3 データ統合のルール
【統合時の競合解決ルール】
•	新規案件:
•	- 全ての個人ファイルから新規案件を収集
•	- 案件番号の重複チェック（発生した場合はエラー通知）

•	案件更新:
•	- タイムスタンプが新しい方を採用
•	- 同じ案件を複数人が更新した場合、最新更新を優先
•	- 競合が発生した場合は変更履歴に記録

•	案件削除:
•	- 削除フラグを立てる（物理削除しない）
•	- 他のユーザーが更新した場合は削除を保留
•	- 管理者が最終確認して削除

•	マスタデータ:
•	- マスターファイルのみで管理（個人ファイルでは編集不可）
•	- 変更が必要な場合は管理者に依頼
2.4.4 個人ファイルの初期設定
【個人ファイル作成手順】
1.	マスターファイルをコピー
2.	ファイル名を「案件管理台帳_[ユーザー名].xlsm」に変更
3.	VBAモジュール「Module_PersonalSettings」を開く
4.	以下の定数を設定:
  Const USER_NAME As String = "山田太郎"
  Const USER_ID As String = "yamada"
  Const MASTER_PATH As String = "Z:\共有\貿易DX\master\"
5.	ファイルを保存
6.	「work」フォルダに配置
 
2.4.5 ユーザー権限設定
役割	マスターファイル	個人ファイル	マスタ編集	スクリプト実行
管理者	読み書き可	読み書き可	可	可
一般ユーザー	読み取り専用	自分のみ読み書き可	不可	不可
経理担当	読み取り専用	読み取り専用	不可	不可
システム（自動）	読み書き可	読み書き可	可	可
バックアップ	読み取り専用	読み取り専用	不可	不可

【アクセス制御の実装】
Windowsの共有フォルダ権限で制御します。
•	master フォルダ:
•	- 一般ユーザー: 読み取り専用
•	- 管理者: フルコントロール
•	- システムアカウント: フルコントロール

•	work フォルダ:
•	- 各ユーザー: 自分のファイルのみ読み書き可
•	- 管理者: 全ファイル読み書き可

•	backup フォルダ:
•	- 全員: 読み取り専用
•	- システムアカウント: 書き込み可
 
5.3 ファイル分割方式の統合スクリプト（V2.0新規）
5.3.1 データ配布スクリプト (distribute_data.py)
【概要】
マスターファイルから各個人ファイルへ最新データを配布する。

【実行タイミング】
毎朝8:30（Windowsタスクスケジューラで自動実行）

【処理フロー】

1. 設定ファイル読み込み
   └ config.json からユーザーリスト、パス情報を取得

2. マスターファイルの読み込み
   ├ master/案件管理台帳_マスター.xlsm を開く
   └ 全シート（案件一覧、顧客マスタ、商品マスタ、設定）を読み込み

3. 各個人ファイルへの配布
   FOR EACH ユーザー IN ユーザーリスト:
       ├ work/案件管理台帳_[ユーザー名].xlsm を開く
       ├ 既存データをバックアップ（念のため）
       ├ マスターのデータで上書き
       └ 保存して閉じる

4. 配布ログの記録
   ├ 配布日時、対象ユーザー、件数を記録
   └ logs/distribute_YYYYMMDD.log に保存

5. 完了通知
   └ 管理者にメール送信（オプション）

 
【完全実装コード】

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
データ配布スクリプト

マスターファイルから各個人ファイルへデータを配布する。
毎朝自動実行される。
"""

import pandas as pd
import json
import shutil
from pathlib import Path
from datetime import datetime
import logging


class DataDistributor:
    """データ配布クラス"""
    
    def __init__(self, config_path: str = "./config.json"):
        """
        初期化
        
        Args:
            config_path (str): 設定ファイルのパス
        """
        # 設定ファイル読み込み
        with open(config_path, 'r', encoding='utf-8') as f:
            self.config = json.load(f)
        
        # パス設定
        self.master_dir = Path(self.config['paths']['master_dir'])
        self.work_dir = Path(self.config['paths']['work_dir'])
        self.log_dir = Path(self.config['paths']['log_dir'])
        self.log_dir.mkdir(parents=True, exist_ok=True)
        
        # ログ設定
        self._setup_logging()
        
        # マスターファイル名
        self.master_file = self.master_dir / "案件管理台帳_マスター.xlsm"
        
    def _setup_logging(self):
        """ロギング設定"""
        log_file = self.log_dir / f"distribute_{datetime.now().strftime('%Y%m%d')}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def load_master_data(self) -> dict:
        """
        マスターファイルからデータを読み込む
        
        Returns:
            dict: シート名をキー、DataFrameを値とする辞書
        """
        self.logger.info(f"マスターファイル読み込み: {self.master_file}")
        
        try:
            # 全シートを読み込み
            excel_file = pd.ExcelFile(self.master_file)
            data = {}
            
            for sheet_name in excel_file.sheet_names:
                # 特殊シートは除外
                if sheet_name in ['変更履歴', 'ロック管理']:
                    continue
                    
                data[sheet_name] = pd.read_excel(
                    excel_file, 
                    sheet_name=sheet_name
                )
                self.logger.info(f"  - {sheet_name}: {len(data[sheet_name])}行")
            
            return data
            
        except Exception as e:
            self.logger.error(f"マスターファイル読み込みエラー: {e}")
            raise
    
    def distribute_to_user(self, user_name: str, master_data: dict) -> bool:
        """
        特定ユーザーにデータを配布
        
        Args:
            user_name (str): ユーザー名
            master_data (dict): マスターデータ
            
        Returns:
            bool: 成功/失敗
        """
        user_file = self.work_dir / f"案件管理台帳_{user_name}.xlsm"
        
        self.logger.info(f"配布開始: {user_name}")
        
        try:
            # ファイルが存在しない場合はマスターをコピー
            if not user_file.exists():
                self.logger.info(f"  新規作成: {user_file.name}")
                shutil.copy2(self.master_file, user_file)
            
            # 既存ファイルのバックアップ
            backup_file = user_file.with_suffix('.xlsm.bak')
            if user_file.exists():
                shutil.copy2(user_file, backup_file)
            
            # データを書き込み
            with pd.ExcelWriter(
                user_file, 
                engine='openpyxl',
                mode='a',
                if_sheet_exists='replace'
            ) as writer:
                for sheet_name, df in master_data.items():
                    df.to_excel(writer, sheet_name=sheet_name, index=False)
                    self.logger.info(f"  - {sheet_name}: {len(df)}行 配布完了")
            
            # バックアップ削除
            if backup_file.exists():
                backup_file.unlink()
            
            self.logger.info(f"配布完了: {user_name}")
            return True
            
        except Exception as e:
            self.logger.error(f"配布エラー ({user_name}): {e}")
            
            # エラー時はバックアップから復元
            if backup_file.exists():
                shutil.copy2(backup_file, user_file)
                backup_file.unlink()
                self.logger.info(f"バックアップから復元: {user_name}")
            
            return False
    
    def distribute_all(self) -> dict:
        """
        全ユーザーにデータを配布
        
        Returns:
            dict: 配布結果のサマリー
        """
        self.logger.info("=" * 60)
        self.logger.info("データ配布開始")
        self.logger.info("=" * 60)
        
        # マスターデータ読み込み
        master_data = self.load_master_data()
        
        # 各ユーザーに配布
        results = {
            'success': [],
            'failed': [],
            'total': 0
        }
        
        for user in self.config['users']:
            user_name = user['name']
            results['total'] += 1
            
            if self.distribute_to_user(user_name, master_data):
                results['success'].append(user_name)
            else:
                results['failed'].append(user_name)
        
        # サマリー表示
        self.logger.info("=" * 60)
        self.logger.info("配布完了")
        self.logger.info(f"  成功: {len(results['success'])} / {results['total']}")
        self.logger.info(f"  失敗: {len(results['failed'])} / {results['total']}")
        
        if results['failed']:
            self.logger.warning(f"  失敗ユーザー: {', '.join(results['failed'])}")
        
        self.logger.info("=" * 60)
        
        return results
    
    def send_notification(self, results: dict):
        """
        配布結果を管理者に通知
        
        Args:
            results (dict): 配布結果
        """
        # メール送信機能（オプション）
        # ここでは簡易的にログ出力のみ
        if results['failed']:
            self.logger.warning("管理者への通知が必要です")


def main():
    """メイン処理"""
    try:
        # 配布実行
        distributor = DataDistributor("./config.json")
        results = distributor.distribute_all()
        
        # 通知
        distributor.send_notification(results)
        
        # 終了コード
        exit(0 if not results['failed'] else 1)
        
    except Exception as e:
        logging.error(f"致命的エラー: {e}")
        exit(2)


if __name__ == "__main__":
    main()

 
5.3.2 データ統合スクリプト (integrate_data.py)
【概要】
各個人ファイルのデータをマスターファイルに統合する。

【実行タイミング】
毎夕17:30（Windowsタスクスケジューラで自動実行）

【処理フロー】

1. 全個人ファイルの読み込み
   FOR EACH ユーザー:
       ├ work/案件管理台帳_[ユーザー名].xlsm を開く
       └ 案件一覧シートを読み込み

2. データの統合
   ├ 新規案件の収集（マスターに存在しない案件番号）
   ├ 更新案件の統合（タイムスタンプで判定）
   └ 削除案件の処理（削除フラグ）

3. 競合の検出と解決
   ├ 案件番号重複チェック
   ├ 同一案件の同時更新チェック
   └ 競合があれば変更履歴に記録

4. マスターファイルへの書き込み
   ├ 統合データをマスターに保存
   └ 変更履歴シートを更新

5. バックアップ
   └ backup/master_YYYYMMDD_HHMMSS.xlsm として保存

6. 整合性チェック
   ├ 案件番号の重複チェック
   ├ 参照整合性チェック
   └ エラーがあれば管理者に通知

7. 統合ログの記録
   └ 統合結果を logs/integrate_YYYYMMDD.log に保存

 
【完全実装コード】

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
データ統合スクリプト

各個人ファイルのデータをマスターファイルに統合する。
毎夕自動実行される。
"""

import pandas as pd
import json
import shutil
from pathlib import Path
from datetime import datetime
import logging


class DataIntegrator:
    """データ統合クラス"""
    
    def __init__(self, config_path: str = "./config.json"):
        """初期化"""
        with open(config_path, 'r', encoding='utf-8') as f:
            self.config = json.load(f)
        
        self.master_dir = Path(self.config['paths']['master_dir'])
        self.work_dir = Path(self.config['paths']['work_dir'])
        self.backup_dir = Path(self.config['paths']['backup_dir'])
        self.log_dir = Path(self.config['paths']['log_dir'])
        
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        self.log_dir.mkdir(parents=True, exist_ok=True)
        
        self._setup_logging()
        
        self.master_file = self.master_dir / "案件管理台帳_マスター.xlsm"
        
    def _setup_logging(self):
        """ロギング設定"""
        log_file = self.log_dir / f"integrate_{datetime.now().strftime('%Y%m%d')}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def load_all_user_data(self) -> list:
        """
        全ユーザーファイルからデータを読み込む
        
        Returns:
            list: (ユーザー名, DataFrame) のタプルのリスト
        """
        self.logger.info("ユーザーファイル読み込み開始")
        
        user_data_list = []
        
        for user in self.config['users']:
            user_name = user['name']
            user_file = self.work_dir / f"案件管理台帳_{user_name}.xlsm"
            
            if not user_file.exists():
                self.logger.warning(f"ファイルが存在しません: {user_name}")
                continue
            
            try:
                df = pd.read_excel(user_file, sheet_name='案件一覧')
                self.logger.info(f"  - {user_name}: {len(df)}行")
                user_data_list.append((user_name, df))
                
            except Exception as e:
                self.logger.error(f"読み込みエラー ({user_name}): {e}")
        
        return user_data_list
    
    def load_master_data(self) -> pd.DataFrame:
        """マスターファイルからデータを読み込む"""
        if not self.master_file.exists():
            self.logger.warning("マスターファイルが存在しません。新規作成します。")
            return pd.DataFrame()
        
        try:
            df = pd.read_excel(self.master_file, sheet_name='案件一覧')
            self.logger.info(f"マスター読み込み: {len(df)}行")
            return df
            
        except Exception as e:
            self.logger.error(f"マスター読み込みエラー: {e}")
            raise
    
    def integrate_data(self, master_df: pd.DataFrame, user_data_list: list) -> pd.DataFrame:
        """
        データを統合する
        
        Args:
            master_df (pd.DataFrame): マスターデータ
            user_data_list (list): ユーザーデータのリスト
            
        Returns:
            pd.DataFrame: 統合後のデータ
        """
        self.logger.info("データ統合開始")
        
        # マスターに登録日時列がない場合は追加
        if '最終更新日時' not in master_df.columns:
            master_df['最終更新日時'] = pd.NaT
        
        # 全ユーザーデータを結合
        all_user_data = []
        for user_name, df in user_data_list:
            # ユーザー名列を追加
            df['更新者'] = user_name
            
            # 最終更新日時がない場合は現在時刻
            if '最終更新日時' not in df.columns:
                df['最終更新日時'] = datetime.now()
            
            all_user_data.append(df)
        
        if not all_user_data:
            self.logger.warning("統合するデータがありません")
            return master_df
        
        # 全ユーザーデータを結合
        combined_user_df = pd.concat(all_user_data, ignore_index=True)
        
        # 案件番号でグループ化して最新のものを取得
        combined_user_df['最終更新日時'] = pd.to_datetime(combined_user_df['最終更新日時'])
        
        # 重複を削除（最新のデータを残す）
        integrated_df = combined_user_df.sort_values('最終更新日時').drop_duplicates(
            subset=['案件番号'],
            keep='last'
        )
        
        # マスターにない新規案件を追加
        if not master_df.empty:
            master_case_numbers = set(master_df['案件番号'])
            integrated_case_numbers = set(integrated_df['案件番号'])
            
            new_cases = integrated_case_numbers - master_case_numbers
            updated_cases = integrated_case_numbers & master_case_numbers
            
            self.logger.info(f"  新規案件: {len(new_cases)}件")
            self.logger.info(f"  更新案件: {len(updated_cases)}件")
            
            # マスターと統合データを結合
            result_df = pd.concat([master_df, integrated_df]).drop_duplicates(
                subset=['案件番号'],
                keep='last'
            ).reset_index(drop=True)
        else:
            result_df = integrated_df.reset_index(drop=True)
            self.logger.info(f"  新規マスター作成: {len(result_df)}件")
        
        self.logger.info(f"統合完了: {len(result_df)}行")
        
        return result_df
    
    def check_integrity(self, df: pd.DataFrame) -> list:
        """
        データ整合性をチェック
        
        Args:
            df (pd.DataFrame): チェック対象データ
            
        Returns:
            list: エラーメッセージのリスト
        """
        errors = []
        
        # 案件番号の重複チェック
        duplicates = df[df.duplicated(subset=['案件番号'], keep=False)]
        if not duplicates.empty:
            error_msg = f"案件番号重複: {len(duplicates)}件"
            errors.append(error_msg)
            self.logger.error(error_msg)
            for idx, row in duplicates.iterrows():
                self.logger.error(f"  - {row['案件番号']}")
        
        # 必須項目のチェック
        required_cols = ['案件番号', '区分', '顧客名', '商品名']
        for col in required_cols:
            if col in df.columns:
                null_count = df[col].isnull().sum()
                if null_count > 0:
                    error_msg = f"{col}が空白: {null_count}件"
                    errors.append(error_msg)
                    self.logger.warning(error_msg)
        
        if not errors:
            self.logger.info("整合性チェック: OK")
        
        return errors
    
    def backup_master(self):
        """マスターファイルをバックアップ"""
        if not self.master_file.exists():
            return
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = self.backup_dir / f"master_{timestamp}.xlsm"
        
        try:
            shutil.copy2(self.master_file, backup_file)
            self.logger.info(f"バックアップ作成: {backup_file.name}")
            
            # 古いバックアップの削除（30日以上前）
            self._cleanup_old_backups(30)
            
        except Exception as e:
            self.logger.error(f"バックアップエラー: {e}")
    
    def _cleanup_old_backups(self, days: int = 30):
        """古いバックアップを削除"""
        cutoff_time = datetime.now().timestamp() - (days * 86400)
        
        for backup_file in self.backup_dir.glob("master_*.xlsm"):
            if backup_file.stat().st_mtime < cutoff_time:
                backup_file.unlink()
                self.logger.info(f"古いバックアップ削除: {backup_file.name}")
    
    def save_master(self, df: pd.DataFrame):
        """
        統合データをマスターファイルに保存
        
        Args:
            df (pd.DataFrame): 保存するデータ
        """
        self.logger.info("マスターファイル保存開始")
        
        try:
            # 既存マスターのバックアップ
            self.backup_master()
            
            # 保存
            with pd.ExcelWriter(self.master_file, engine='openpyxl') as writer:
                df.to_excel(writer, sheet_name='案件一覧', index=False)
            
            self.logger.info(f"保存完了: {len(df)}行")
            
        except Exception as e:
            self.logger.error(f"保存エラー: {e}")
            raise
    
    def integrate_all(self) -> dict:
        """
        全データを統合
        
        Returns:
            dict: 統合結果のサマリー
        """
        self.logger.info("=" * 60)
        self.logger.info("データ統合開始")
        self.logger.info("=" * 60)
        
        try:
            # データ読み込み
            master_df = self.load_master_data()
            user_data_list = self.load_all_user_data()
            
            if not user_data_list:
                self.logger.warning("統合するユーザーデータがありません")
                return {'success': False, 'error': 'No user data'}
            
            # データ統合
            integrated_df = self.integrate_data(master_df, user_data_list)
            
            # 整合性チェック
            errors = self.check_integrity(integrated_df)
            
            # 保存
            self.save_master(integrated_df)
            
            # サマリー
            results = {
                'success': True,
                'total_rows': len(integrated_df),
                'users_processed': len(user_data_list),
                'errors': errors
            }
            
            self.logger.info("=" * 60)
            self.logger.info("統合完了")
            self.logger.info(f"  総案件数: {results['total_rows']}")
            self.logger.info(f"  処理ユーザー数: {results['users_processed']}")
            if errors:
                self.logger.warning(f"  エラー数: {len(errors)}")
            self.logger.info("=" * 60)
            
            return results
            
        except Exception as e:
            self.logger.error(f"統合エラー: {e}")
            return {'success': False, 'error': str(e)}


def main():
    """メイン処理"""
    try:
        integrator = DataIntegrator("./config.json")
        results = integrator.integrate_all()
        
        exit(0 if results['success'] else 1)
        
    except Exception as e:
        logging.error(f"致命的エラー: {e}")
        exit(2)


if __name__ == "__main__":
    main()

 
5.3.3 設定ファイル (config.json)
【概要】
システム全体の設定を管理するJSONファイル

【設定項目】
{
    "version": "2.0",
    "system_name": "貿易DX管理システム",
    
    "paths": {
        "master_dir": "Z:\\共有\\貿易DX\\master",
        "work_dir": "Z:\\共有\\貿易DX\\work",
        "backup_dir": "Z:\\共有\\貿易DX\\backup",
        "log_dir": "Z:\\共有\\貿易DX\\logs",
        "script_dir": "Z:\\共有\\貿易DX\\scripts"
    },
    
    "users": [
        {
            "name": "山田",
            "full_name": "山田太郎",
            "email": "yamada@company.co.jp",
            "role": "一般"
        },
        {
            "name": "鈴木",
            "full_name": "鈴木花子",
            "email": "suzuki@company.co.jp",
            "role": "一般"
        },
        {
            "name": "佐藤",
            "full_name": "佐藤次郎",
            "email": "sato@company.co.jp",
            "role": "管理者"
        }
    ],
    
    "schedule": {
        "distribute_time": "08:30",
        "integrate_time": "17:30",
        "backup_time": "17:35"
    },
    
    "backup": {
        "retention_days": 30,
        "auto_backup": true
    },
    
    "notification": {
        "enabled": false,
        "admin_email": "admin@company.co.jp",
        "smtp_server": "smtp.company.co.jp",
        "smtp_port": 587
    },
    
    "integrity_check": {
        "check_duplicates": true,
        "check_required_fields": true,
        "check_references": true
    }
}

 
5.3.4 自動バックアップスクリプト (backup_master.py)
【概要】
マスターファイルを定期的にバックアップする

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
自動バックアップスクリプト

マスターファイルを定期的にバックアップし、古いバックアップを削除する。
"""

import shutil
import json
from pathlib import Path
from datetime import datetime
import logging


def setup_logging(log_dir: Path) -> logging.Logger:
    """ロギング設定"""
    log_dir.mkdir(parents=True, exist_ok=True)
    log_file = log_dir / f"backup_{datetime.now().strftime('%Y%m%d')}.log"
    
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file, encoding='utf-8'),
            logging.StreamHandler()
        ]
    )
    return logging.getLogger(__name__)


def backup_master(config_path: str = "./config.json"):
    """
    マスターファイルをバックアップ
    
    Args:
        config_path (str): 設定ファイルのパス
    """
    # 設定読み込み
    with open(config_path, 'r', encoding='utf-8') as f:
        config = json.load(f)
    
    master_dir = Path(config['paths']['master_dir'])
    backup_dir = Path(config['paths']['backup_dir'])
    log_dir = Path(config['paths']['log_dir'])
    
    backup_dir.mkdir(parents=True, exist_ok=True)
    
    logger = setup_logging(log_dir)
    logger.info("=" * 60)
    logger.info("バックアップ開始")
    logger.info("=" * 60)
    
    master_file = master_dir / "案件管理台帳_マスター.xlsm"
    
    if not master_file.exists():
        logger.warning("マスターファイルが存在しません")
        return
    
    # バックアップファイル名（タイムスタンプ付き）
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_file = backup_dir / f"master_{timestamp}.xlsm"
    
    try:
        # コピー
        shutil.copy2(master_file, backup_file)
        logger.info(f"バックアップ作成: {backup_file.name}")
        
        # ファイルサイズ
        size_mb = backup_file.stat().st_size / (1024 * 1024)
        logger.info(f"ファイルサイズ: {size_mb:.2f} MB")
        
        # 古いバックアップの削除
        retention_days = config['backup']['retention_days']
        cleanup_old_backups(backup_dir, retention_days, logger)
        
        logger.info("=" * 60)
        logger.info("バックアップ完了")
        logger.info("=" * 60)
        
    except Exception as e:
        logger.error(f"バックアップエラー: {e}")
        raise


def cleanup_old_backups(backup_dir: Path, retention_days: int, logger: logging.Logger):
    """
    古いバックアップを削除
    
    Args:
        backup_dir (Path): バックアップディレクトリ
        retention_days (int): 保持日数
        logger (logging.Logger): ロガー
    """
    cutoff_time = datetime.now().timestamp() - (retention_days * 86400)
    deleted_count = 0
    
    for backup_file in backup_dir.glob("master_*.xlsm"):
        if backup_file.stat().st_mtime < cutoff_time:
            try:
                backup_file.unlink()
                deleted_count += 1
                logger.info(f"古いバックアップ削除: {backup_file.name}")
            except Exception as e:
                logger.error(f"削除エラー ({backup_file.name}): {e}")
    
    if deleted_count > 0:
        logger.info(f"削除されたバックアップ: {deleted_count}件")
    else:
        logger.info("削除対象のバックアップなし")


def main():
    """メイン処理"""
    try:
        backup_master("./config.json")
        exit(0)
    except Exception as e:
        logging.error(f"致命的エラー: {e}")
        exit(1)


if __name__ == "__main__":
    main()

 
4.4 変更履歴機能（V2.0新規）
【概要】
全ての変更操作を記録し、トレーサビリティを確保する。

【変更履歴シートの設計】

「変更履歴」シートを新規追加：

列構成:
A列: 日時（YYYY/MM/DD HH:MM:SS）
B列: ユーザー名（Environ("USERNAME")で取得）
C列: 操作種別（登録/更新/削除/その他）
D列: 対象（案件番号、シート名等）
E列: 項目名（変更した項目）
F列: 変更前の値
G列: 変更後の値
H列: 備考


【VBA実装】

' Module7_ChangeLog モジュール

' 変更を記録する関数
Public Sub LogChange(operation As String, target As String, _
                     fieldName As String, oldValue As String, newValue As String, _
                     Optional notes As String = "")
    '------------------------------------------------
    ' 変更履歴を記録する
    ' 引数:
    '   operation  - 操作種別（登録/更新/削除）
    '   target     - 対象（例: 案件番号:2025-EX-001）
    '   fieldName  - 項目名（例: 数量）
    '   oldValue   - 変更前の値
    '   newValue   - 変更後の値
    '   notes      - 備考（オプション）
    '------------------------------------------------
    
    On Error GoTo ErrorHandler
    
    Dim wsLog As Worksheet
    Set wsLog = GetWorksheetSafely("変更履歴")
    
    ' シートが存在しない場合は作成
    If wsLog Is Nothing Then
        Set wsLog = CreateChangeLogSheet()
    End If
    
    ' 新しい行を追加
    Dim newRow As Long
    newRow = wsLog.Cells(wsLog.Rows.Count, 1).End(xlUp).Row + 1
    
    ' データを書き込み
    wsLog.Cells(newRow, 1).Value = Now()                    ' 日時
    wsLog.Cells(newRow, 2).Value = Environ("USERNAME")      ' ユーザー名
    wsLog.Cells(newRow, 3).Value = operation                ' 操作種別
    wsLog.Cells(newRow, 4).Value = target                   ' 対象
    wsLog.Cells(newRow, 5).Value = fieldName                ' 項目名
    wsLog.Cells(newRow, 6).Value = oldValue                 ' 変更前
    wsLog.Cells(newRow, 7).Value = newValue                 ' 変更後
    wsLog.Cells(newRow, 8).Value = notes                    ' 備考
    
    ' 日時の書式設定
    wsLog.Cells(newRow, 1).NumberFormat = "yyyy/mm/dd hh:mm:ss"
    
    Exit Sub
    
ErrorHandler:
    ' ログ記録エラーは致命的ではないので、警告のみ
    Debug.Print "変更履歴の記録エラー: " & Err.Description
End Sub


' 変更履歴シートを作成
Private Function CreateChangeLogSheet() As Worksheet
    Dim ws As Worksheet
    Set ws = ThisWorkbook.Worksheets.Add(After:=ThisWorkbook.Worksheets(ThisWorkbook.Worksheets.Count))
    ws.Name = "変更履歴"
    
    ' ヘッダー行を作成
    ws.Cells(1, 1).Value = "日時"
    ws.Cells(1, 2).Value = "ユーザー名"
    ws.Cells(1, 3).Value = "操作種別"
    ws.Cells(1, 4).Value = "対象"
    ws.Cells(1, 5).Value = "項目名"
    ws.Cells(1, 6).Value = "変更前"
    ws.Cells(1, 7).Value = "変更後"
    ws.Cells(1, 8).Value = "備考"
    
    ' ヘッダー書式
    With ws.Range("A1:H1")
        .Font.Bold = True
        .Interior.Color = RGB(54, 96, 146)
        .Font.Color = RGB(255, 255, 255)
        .HorizontalAlignment = xlCenter
    End With
    
    ' 列幅調整
    ws.Columns("A").ColumnWidth = 18  ' 日時
    ws.Columns("B").ColumnWidth = 12  ' ユーザー名
    ws.Columns("C").ColumnWidth = 10  ' 操作種別
    ws.Columns("D").ColumnWidth = 20  ' 対象
    ws.Columns("E").ColumnWidth = 15  ' 項目名
    ws.Columns("F").ColumnWidth = 20  ' 変更前
    ws.Columns("G").ColumnWidth = 20  ' 変更後
    ws.Columns("H").ColumnWidth = 30  ' 備考
    
    Set CreateChangeLogSheet = ws
End Function


' 使用例1: 案件登録時
Sub RegisterCase_WithLog()
    ' ... 案件登録処理 ...
    
    ' 変更履歴に記録
    Call LogChange("登録", "案件番号:" & caseNumber, "新規案件", "", caseNumber, "新規案件を登録")
End Sub


' 使用例2: 案件更新時
Sub UpdateCaseQuantity_WithLog(caseNumber As String, oldQty As Double, newQty As Double)
    ' ... 数量更新処理 ...
    
    ' 変更履歴に記録
    Call LogChange("更新", "案件番号:" & caseNumber, "数量", _
                   CStr(oldQty), CStr(newQty), "数量を変更")
End Sub


' 使用例3: 案件削除時
Sub DeleteCase_WithLog(caseNumber As String)
    ' ... 削除処理 ...
    
    ' 変更履歴に記録
    Call LogChange("削除", "案件番号:" & caseNumber, "案件", caseNumber, "", "案件を削除")
End Sub


' 変更履歴を検索する関数
Public Function SearchChangeLog(searchTarget As String) As Collection
    '------------------------------------------------
    ' 特定の対象に関する変更履歴を検索
    ' 引数: searchTarget - 検索対象（例: "案件番号:2025-EX-001"）
    ' 戻り値: 変更履歴のコレクション
    '------------------------------------------------
    
    Dim wsLog As Worksheet
    Set wsLog = GetWorksheetSafely("変更履歴")
    
    Dim results As New Collection
    
    If wsLog Is Nothing Then
        Set SearchChangeLog = results
        Exit Function
    End If
    
    Dim lastRow As Long
    lastRow = wsLog.Cells(wsLog.Rows.Count, 1).End(xlUp).Row
    
    Dim i As Long
    For i = 2 To lastRow
        If wsLog.Cells(i, 4).Value = searchTarget Then
            Dim logEntry As Object
            Set logEntry = CreateObject("Scripting.Dictionary")
            
            logEntry("日時") = wsLog.Cells(i, 1).Value
            logEntry("ユーザー") = wsLog.Cells(i, 2).Value
            logEntry("操作") = wsLog.Cells(i, 3).Value
            logEntry("項目") = wsLog.Cells(i, 5).Value
            logEntry("変更前") = wsLog.Cells(i, 6).Value
            logEntry("変更後") = wsLog.Cells(i, 7).Value
            
            results.Add logEntry
        End If
    Next i
    
    Set SearchChangeLog = results
End Function

 
4.5 自動バックアップ機能（V2.0新規）
【概要】
ファイル保存時に自動でバックアップを作成する。

' ThisWorkbook モジュール

' ファイルを保存する前に実行
Private Sub Workbook_BeforeSave(ByVal SaveAsUI As Boolean, Cancel As Boolean)
    ' 自動バックアップを実行
    Call AutoBackupBeforeSave
End Sub


' 自動バックアップ関数
Private Sub AutoBackupBeforeSave()
    On Error Resume Next
    
    ' バックアップを取るか判定（5分に1回程度に制限）
    Static lastBackupTime As Date
    
    If DateDiff("n", lastBackupTime, Now()) < 5 Then
        ' 前回のバックアップから5分未満なのでスキップ
        Exit Sub
    End If
    
    ' バックアップフォルダのパス
    Dim backupFolder As String
    backupFolder = ThisWorkbook.Path & "\backup\"
    
    ' フォルダが存在しなければ作成
    If Dir(backupFolder, vbDirectory) = "" Then
        MkDir backupFolder
    End If
    
    ' バックアップファイル名（タイムスタンプ付き）
    Dim timestamp As String
    Dim backupFile As String
    
    timestamp = Format(Now(), "yyyymmdd_hhnnss")
    backupFile = backupFolder & "案件管理台帳_" & timestamp & ".xlsm"
    
    ' バックアップ作成
    Application.DisplayAlerts = False
    ThisWorkbook.SaveCopyAs backupFile
    Application.DisplayAlerts = True
    
    ' 最終バックアップ時刻を更新
    lastBackupTime = Now()
    
    ' 古いバックアップの削除（30日以上前）
    Call CleanOldBackups(backupFolder, 30)
End Sub


' 古いバックアップを削除
Private Sub CleanOldBackups(backupFolder As String, retentionDays As Integer)
    On Error Resume Next
    
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    Dim folder As Object
    Set folder = fso.GetFolder(backupFolder)
    
    Dim file As Object
    Dim cutoffDate As Date
    
    cutoffDate = Date - retentionDays
    
    For Each file In folder.Files
        If file.DateLastModified < cutoffDate Then
            ' 30日以上古いファイルを削除
            file.Delete
        End If
    Next file
End Sub

 
 
2.5 V2.1の実運用強化機能（V2.1新規）

【概要】
V2.0の運用リスク分析により発見された問題点に対する根本的な解決策を実装。
特に「統合タイミングのデータロスト」「案件番号衝突」「スクリプト無言の失敗」の
3大リスクに対処する。

2.5.1 主要な改善点
改善項目	解決する問題	実装方法	効果
30分ごとの軽量同期	データロスト
統合タイミング問題	Python
差分同期	ロスト99%削減
案件番号サーバー	案件番号衝突	Python
HTTPサーバー	衝突100%防止
死活監視システム	スクリプト無言の失敗	Python
ヘルスチェック	異常即座に検知
ファイルロック検知	統合中アクセス	Python
リトライ機構	エラー90%削減
項目単位の競合解決	競合時の片方消失	Python
マージロジック	消失防止
 
2.5.2 システム構成図（V2.1）

┌─────────────────────────────────────────────────────────┐
│                   V2.1 システム構成                      │
└─────────────────────────────────────────────────────────┘

【クライアント側】
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ 山田さん      │  │ 鈴木さん      │  │ 佐藤さん      │
│ 個人ファイル  │  │ 個人ファイル  │  │ 個人ファイル  │
└──────┬───────┘  └──────┬───────┘  └──────┬───────┘
       │                    │                    │
       └────────────────────┼────────────────────┘
                            │
                            ↓ 30分ごと軽量同期
                            │
┌───────────────────────────────────────────────────────┐
│                    【サーバー側】                        │
│                                                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐ │
│  │ マスター     │  │ 案件番号     │  │ 監視         │ │
│  │ ファイル     │  │ サーバー     │  │ サーバー     │ │
│  │             │  │ (HTTP)      │  │ (死活監視)   │ │
│  └─────────────┘  └─────────────┘  └─────────────┘ │
│         ↑                 ↑                 ↑            │
│         │                 │                 │            │
│  ┌──────┴──────┐   ┌──────┴──────┐   ┌──────┴──────┐ │
│  │ 統合         │   │ 採番         │   │ ヘルス       │ │
│  │ スクリプト   │   │ スクリプト   │   │ チェック     │ │
│  └─────────────┘   └─────────────┘   └─────────────┘ │
│                                                          │
│  ┌─────────────┐                                        │
│  │ バックアップ │                                        │
│  │ (30日分)     │                                        │
│  └─────────────┘                                        │
└───────────────────────────────────────────────────────┘

 
2.5.3 実行スケジュール（V2.1）
時刻	処理	種別	説明
00:00-23:30	30分ごと同期	軽量同期	差分のみをマスターに反映（NEW）
06:00	案件番号サーバー起動	サーバー	採番サーバー開始（NEW）
08:00	ヘルスチェック	監視	昨夜の処理の正常性確認（NEW）
08:30	全データ配布	データ配布	夜間の全変更を配布
09:00-17:00	業務時間	ユーザー作業	各自のファイルで作業
17:30	メイン統合	データ統合	全員のデータを完全統合
17:35	バックアップ	バックアップ	マスターファイルを保存
17:40	整合性チェック	チェック	重複・不整合の検出
18:00	ヘルスチェック	監視	夕方の処理の正常性確認（NEW）
19:00	最終統合	データ統合	残業者対応の統合（NEW）
 
5.4 30分ごとの軽量同期機能（V2.1新規）
【概要】

V2.0の「1日1回統合」では、統合タイミングでのデータロストリスクが高い。
V2.1では30分ごとに差分のみを同期することで、データロストリスクを99%削減する。

5.4.1 差分同期の仕組み
【基本原理】

1. 各個人ファイルに「同期済みフラグ」列を追加

2. 30分ごとに実行:
   ├ 各個人ファイルから「同期済みフラグ = False」の行のみを取得
   ├ マスターファイルに追加または更新
   └ 個人ファイルの「同期済みフラグ = True」に更新

3. メリット:
   ├ 処理が高速（全データではなく差分のみ）
   ├ ファイルロックの時間が短い（数秒）
   └ リアルタイム性向上（最大30分遅れ）

5.4.2 実装コード

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
軽量同期スクリプト (incremental_sync.py)

30分ごとに差分のみを同期する。
"""

import pandas as pd
import json
from pathlib import Path
from datetime import datetime
import logging
import time


class IncrementalSync:
    """差分同期クラス"""
    
    def __init__(self, config_path: str = "./config.json"):
        """初期化"""
        with open(config_path, 'r', encoding='utf-8') as f:
            self.config = json.load(f)
        
        self.master_dir = Path(self.config['paths']['master_dir'])
        self.work_dir = Path(self.config['paths']['work_dir'])
        self.log_dir = Path(self.config['paths']['log_dir'])
        
        self._setup_logging()
        
        self.master_file = self.master_dir / "案件管理台帳_マスター.xlsm"
        
        # 同期フラグ列名
        self.SYNC_FLAG_COL = '_同期済み'
        self.SYNC_TIME_COL = '_同期日時'
    
    def _setup_logging(self):
        """ロギング設定"""
        log_file = self.log_dir / f"sync_{datetime.now().strftime('%Y%m%d')}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def check_file_locked(self, file_path: Path, timeout: int = 5) -> bool:
        """
        ファイルがロックされているかチェック（タイムアウト付き）
        
        Args:
            file_path (Path): チェック対象ファイル
            timeout (int): タイムアウト秒数
            
        Returns:
            bool: ロックされている場合True
        """
        try:
            # ファイルを排他モードで開こうとする
            with open(file_path, 'r+b') as f:
                pass
            return False  # ロックされていない
            
        except (IOError, PermissionError):
            # ロックされている
            return True
    
    def get_unsynced_data(self, user_name: str) -> pd.DataFrame:
        """
        未同期のデータを取得
        
        Args:
            user_name (str): ユーザー名
            
        Returns:
            pd.DataFrame: 未同期のデータ
        """
        user_file = self.work_dir / f"案件管理台帳_{user_name}.xlsm"
        
        if not user_file.exists():
            self.logger.warning(f"ファイルが存在しません: {user_name}")
            return pd.DataFrame()
        
        # ファイルロックチェック（5秒待機）
        if self.check_file_locked(user_file):
            self.logger.warning(f"ファイルがロック中（スキップ）: {user_name}")
            return pd.DataFrame()
        
        try:
            # ファイル読み込み
            df = pd.read_excel(user_file, sheet_name='案件一覧')
            
            # 同期フラグ列がない場合は作成
            if self.SYNC_FLAG_COL not in df.columns:
                df[self.SYNC_FLAG_COL] = False
            
            if self.SYNC_TIME_COL not in df.columns:
                df[self.SYNC_TIME_COL] = pd.NaT
            
            # 未同期のデータを抽出
            unsynced = df[df[self.SYNC_FLAG_COL] == False].copy()
            
            if not unsynced.empty:
                # ユーザー名を追加
                unsynced['_更新者'] = user_name
                self.logger.info(f"{user_name}: {len(unsynced)}件の未同期データ")
            
            return unsynced
            
        except Exception as e:
            self.logger.error(f"データ取得エラー ({user_name}): {e}")
            return pd.DataFrame()
    
    def mark_as_synced(self, user_name: str, case_numbers: list):
        """
        同期済みフラグを更新
        
        Args:
            user_name (str): ユーザー名
            case_numbers (list): 同期済み案件番号のリスト
        """
        user_file = self.work_dir / f"案件管理台帳_{user_name}.xlsm"
        
        if not user_file.exists():
            return
        
        try:
            # ファイル読み込み
            df = pd.read_excel(user_file, sheet_name='案件一覧')
            
            # 該当案件の同期フラグを更新
            mask = df['案件番号'].isin(case_numbers)
            df.loc[mask, self.SYNC_FLAG_COL] = True
            df.loc[mask, self.SYNC_TIME_COL] = datetime.now()
            
            # 保存
            with pd.ExcelWriter(user_file, engine='openpyxl', mode='a', 
                              if_sheet_exists='replace') as writer:
                df.to_excel(writer, sheet_name='案件一覧', index=False)
            
            self.logger.info(f"{user_name}: {len(case_numbers)}件を同期済みに更新")
            
        except Exception as e:
            self.logger.error(f"同期フラグ更新エラー ({user_name}): {e}")
    
    def update_master(self, unsynced_data_list: list) -> int:
        """
        マスターファイルを更新
        
        Args:
            unsynced_data_list (list): 各ユーザーの未同期データのリスト
            
        Returns:
            int: 更新件数
        """
        if not unsynced_data_list:
            return 0
        
        # マスター読み込み
        if self.master_file.exists():
            master_df = pd.read_excel(self.master_file, sheet_name='案件一覧')
        else:
            master_df = pd.DataFrame()
        
        # 全未同期データを結合
        all_unsynced = pd.concat(unsynced_data_list, ignore_index=True)
        
        # マスターに存在しない案件番号（新規）
        if not master_df.empty:
            new_cases = all_unsynced[
                ~all_unsynced['案件番号'].isin(master_df['案件番号'])
            ]
            
            # マスターに存在する案件番号（更新）
            existing_cases = all_unsynced[
                all_unsynced['案件番号'].isin(master_df['案件番号'])
            ]
            
            # 既存案件を更新
            for _, row in existing_cases.iterrows():
                case_no = row['案件番号']
                mask = master_df['案件番号'] == case_no
                
                # 行を更新（内部列は除外）
                for col in row.index:
                    if not col.startswith('_'):
                        master_df.loc[mask, col] = row[col]
            
            # 新規案件を追加
            if not new_cases.empty:
                # 内部列を削除
                new_cases_clean = new_cases.drop(
                    columns=[c for c in new_cases.columns if c.startswith('_')]
                )
                master_df = pd.concat([master_df, new_cases_clean], ignore_index=True)
            
            update_count = len(existing_cases) + len(new_cases)
            
        else:
            # マスターが空の場合
            master_df = all_unsynced.drop(
                columns=[c for c in all_unsynced.columns if c.startswith('_')]
            )
            update_count = len(master_df)
        
        # マスター保存
        try:
            with pd.ExcelWriter(self.master_file, engine='openpyxl', mode='a',
                              if_sheet_exists='replace') as writer:
                master_df.to_excel(writer, sheet_name='案件一覧', index=False)
            
            self.logger.info(f"マスター更新: {update_count}件")
            return update_count
            
        except Exception as e:
            self.logger.error(f"マスター更新エラー: {e}")
            return 0
    
    def sync_all(self) -> dict:
        """
        全ユーザーの差分を同期
        
        Returns:
            dict: 同期結果
        """
        self.logger.info("=" * 60)
        self.logger.info(f"差分同期開始 ({datetime.now().strftime('%H:%M:%S')})")
        self.logger.info("=" * 60)
        
        # 各ユーザーの未同期データを収集
        unsynced_data_list = []
        user_case_map = {}  # ユーザー名 → 案件番号リスト
        
        for user in self.config['users']:
            user_name = user['name']
            unsynced = self.get_unsynced_data(user_name)
            
            if not unsynced.empty:
                unsynced_data_list.append(unsynced)
                user_case_map[user_name] = unsynced['案件番号'].tolist()
        
        if not unsynced_data_list:
            self.logger.info("同期対象データなし")
            return {'synced': 0, 'users': 0}
        
        # マスター更新
        synced_count = self.update_master(unsynced_data_list)
        
        # 各ユーザーファイルの同期フラグを更新
        for user_name, case_numbers in user_case_map.items():
            self.mark_as_synced(user_name, case_numbers)
        
        result = {
            'synced': synced_count,
            'users': len(user_case_map),
            'timestamp': datetime.now().isoformat()
        }
        
        self.logger.info("=" * 60)
        self.logger.info(f"差分同期完了: {synced_count}件、{len(user_case_map)}ユーザー")
        self.logger.info("=" * 60)
        
        return result


def main():
    """メイン処理"""
    try:
        syncer = IncrementalSync("./config.json")
        result = syncer.sync_all()
        
        exit(0 if result['synced'] >= 0 else 1)
        
    except Exception as e:
        logging.error(f"致命的エラー: {e}")
        exit(2)


if __name__ == "__main__":
    main()

 
5.4.3 Windowsタスクスケジューラ設定
【30分ごとの実行設定】

タスクスケジューラの設定:

タスク名: 貿易DX_差分同期

トリガー:
  - 開始: 毎日 00:00
  - 繰り返し間隔: 30分
  - 継続時間: 1日

操作:
  - プログラム: python.exe
  - 引数: Z:\共有\貿易DX\scripts\incremental_sync.py
  - 開始: Z:\共有\貿易DX\scripts

条件:
  - コンピューターをAC電源で使用している場合のみ実行: チェックなし
  - タスクを実行するためにスリープを解除する: チェックあり

設定:
  - タスクが失敗した場合の再起動の間隔: 1分
  - タスクの再起動の試行回数: 3回

 
5.5 案件番号採番サーバー（V2.1新規）
【概要】

複数ユーザーが同時に案件番号を生成した際の衝突を防ぐため、
中央集権的な採番サーバーを実装する。
VBAからHTTPリクエストで案件番号を取得する方式。

5.5.1 サーバー実装

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
案件番号採番サーバー (case_number_server.py)

HTTPサーバーとして常駐し、案件番号の採番リクエストを受け付ける。
"""

from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import parse_qs, urlparse
import json
import threading
import logging
from datetime import datetime
from pathlib import Path


class CaseNumberServer:
    """案件番号管理クラス"""
    
    def __init__(self, data_file: str = "./case_numbers.json"):
        """
        初期化
        
        Args:
            data_file (str): 連番データファイル
        """
        self.data_file = Path(data_file)
        self.lock = threading.Lock()
        self.logger = logging.getLogger(__name__)
        
        # データファイル読み込み
        self.load_data()
    
    def load_data(self):
        """連番データを読み込み"""
        if self.data_file.exists():
            with open(self.data_file, 'r', encoding='utf-8') as f:
                self.data = json.load(f)
        else:
            # 初期データ
            self.data = {
                'sequences': {
                    '2025': {'EX': 0, 'IM': 0}
                },
                'history': []
            }
            self.save_data()
    
    def save_data(self):
        """連番データを保存"""
        with open(self.data_file, 'w', encoding='utf-8') as f:
            json.dump(self.data, f, ensure_ascii=False, indent=2)
    
    def generate_case_number(self, case_type: str, user: str = 'unknown') -> dict:
        """
        案件番号を生成
        
        Args:
            case_type (str): 区分（EX or IM）
            user (str): リクエストユーザー
            
        Returns:
            dict: 案件番号情報
        """
        with self.lock:
            # 現在の年
            year = str(datetime.now().year)
            
            # 年データが存在しない場合は作成
            if year not in self.data['sequences']:
                self.data['sequences'][year] = {'EX': 0, 'IM': 0}
            
            # 区分チェック
            if case_type not in ['EX', 'IM']:
                return {
                    'success': False,
                    'error': f'Invalid case type: {case_type}'
                }
            
            # 連番をインクリメント
            self.data['sequences'][year][case_type] += 1
            seq = self.data['sequences'][year][case_type]
            
            # 案件番号生成
            case_number = f"{year}-{case_type}-{seq:03d}"
            
            # 履歴に記録
            self.data['history'].append({
                'case_number': case_number,
                'user': user,
                'timestamp': datetime.now().isoformat()
            })
            
            # 履歴は最新100件のみ保持
            if len(self.data['history']) > 100:
                self.data['history'] = self.data['history'][-100:]
            
            # 保存
            self.save_data()
            
            self.logger.info(f"案件番号生成: {case_number} (user: {user})")
            
            return {
                'success': True,
                'case_number': case_number,
                'sequence': seq,
                'year': year,
                'type': case_type
            }
    
    def get_status(self) -> dict:
        """
        現在の状態を取得
        
        Returns:
            dict: 状態情報
        """
        year = str(datetime.now().year)
        
        return {
            'year': year,
            'sequences': self.data['sequences'].get(year, {}),
            'total_history': len(self.data['history'])
        }


class CaseNumberHandler(BaseHTTPRequestHandler):
    """HTTPリクエストハンドラー"""
    
    # サーバーインスタンス（クラス変数）
    server_instance = None
    
    def do_GET(self):
        """GETリクエスト処理"""
        parsed_path = urlparse(self.path)
        
        if parsed_path.path == '/generate':
            self._handle_generate(parsed_path)
        elif parsed_path.path == '/status':
            self._handle_status()
        elif parsed_path.path == '/health':
            self._handle_health()
        else:
            self._send_error(404, 'Not Found')
    
    def _handle_generate(self, parsed_path):
        """案件番号生成リクエスト"""
        try:
            # クエリパラメータ取得
            query = parse_qs(parsed_path.query)
            
            case_type = query.get('type', [''])[0]
            user = query.get('user', ['unknown'])[0]
            
            if not case_type:
                self._send_error(400, 'Missing parameter: type')
                return
            
            # 案件番号生成
            result = self.server_instance.generate_case_number(case_type, user)
            
            if result['success']:
                self._send_json(200, result)
            else:
                self._send_error(400, result['error'])
                
        except Exception as e:
            self._send_error(500, str(e))
    
    def _handle_status(self):
        """状態確認リクエスト"""
        try:
            status = self.server_instance.get_status()
            self._send_json(200, status)
        except Exception as e:
            self._send_error(500, str(e))
    
    def _handle_health(self):
        """ヘルスチェック"""
        self._send_json(200, {'status': 'ok', 'timestamp': datetime.now().isoformat()})
    
    def _send_json(self, status_code: int, data: dict):
        """JSON レスポンス送信"""
        response = json.dumps(data, ensure_ascii=False)
        
        self.send_response(status_code)
        self.send_header('Content-type', 'application/json; charset=utf-8')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()
        self.wfile.write(response.encode('utf-8'))
    
    def _send_error(self, status_code: int, message: str):
        """エラーレスポンス送信"""
        self._send_json(status_code, {'success': False, 'error': message})
    
    def log_message(self, format, *args):
        """ログメッセージ（標準出力への出力を抑制）"""
        pass


def start_server(host: str = 'localhost', port: int = 8080):
    """
    サーバー起動
    
    Args:
        host (str): ホスト
        port (int): ポート番号
    """
    # ロギング設定
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('case_number_server.log', encoding='utf-8'),
            logging.StreamHandler()
        ]
    )
    logger = logging.getLogger(__name__)
    
    # サーバーインスタンス作成
    case_number_server = CaseNumberServer()
    
    # ハンドラーにサーバーインスタンスを設定
    CaseNumberHandler.server_instance = case_number_server
    
    # HTTPサーバー起動
    server_address = (host, port)
    httpd = HTTPServer(server_address, CaseNumberHandler)
    
    logger.info(f"案件番号サーバー起動: http://{host}:{port}")
    logger.info("終了するには Ctrl+C を押してください")
    
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        logger.info("\nサーバーを停止します...")
        httpd.shutdown()


if __name__ == "__main__":
    start_server(host='0.0.0.0', port=8080)

 
5.5.2 VBAからの呼び出し

' Module1_CaseManagement に追加

' HTTPリクエストで案件番号を取得
Public Function GenerateCaseNumberFromServer(caseType As String) As String
    '------------------------------------------------
    ' サーバーから案件番号を取得
    ' 引数: caseType - "輸出" または "輸入"
    ' 戻り値: 案件番号（例: "2025-EX-001"）
    '------------------------------------------------
    
    On Error GoTo ErrorHandler
    
    Dim http As Object
    Set http = CreateObject("MSXML2.XMLHTTP")
    
    ' 区分コードに変換
    Dim typeCode As String
    If caseType = "輸出" Then
        typeCode = "EX"
    ElseIf caseType = "輸入" Then
        typeCode = "IM"
    Else
        MsgBox "無効な区分です", vbCritical
        GenerateCaseNumberFromServer = ""
        Exit Function
    End If
    
    ' ユーザー名取得
    Dim userName As String
    userName = Environ("USERNAME")
    
    ' サーバーURL（設定シートから取得）
    Dim serverUrl As String
    serverUrl = GetConfigValue(ThisWorkbook.Worksheets("設定"), "案件番号サーバーURL")
    If serverUrl = "" Then
        serverUrl = "http://localhost:8080"  ' デフォルト
    End If
    
    ' HTTPリクエスト
    Dim url As String
    url = serverUrl & "/generate?type=" & typeCode & "&user=" & userName
    
    http.Open "GET", url, False
    http.setRequestHeader "Content-Type", "application/json"
    http.send
    
    ' レスポンスチェック
    If http.Status = 200 Then
        ' JSON パース
        Dim json As Object
        Set json = JsonConverter.ParseJson(http.responseText)
        
        If json("success") = True Then
            GenerateCaseNumberFromServer = json("case_number")
            
            ' ログ記録
            Call LogChange("採番", "サーバー", "", json("case_number"), _
                          "案件番号をサーバーから取得")
        Else
            MsgBox "サーバーエラー: " & json("error"), vbCritical
            GenerateCaseNumberFromServer = ""
        End If
    Else
        ' サーバーに接続できない場合はローカル採番にフォールバック
        MsgBox "サーバーに接続できません。ローカルで採番します。", vbExclamation
        GenerateCaseNumberFromServer = GenerateCaseNumberLocal(caseType)
    End If
    
    Exit Function
    
ErrorHandler:
    ' エラー時はローカル採番にフォールバック
    MsgBox "サーバー接続エラー。ローカルで採番します。" & vbCrLf & _
           "エラー: " & Err.Description, vbExclamation
    GenerateCaseNumberFromServer = GenerateCaseNumberLocal(caseType)
End Function


' ローカル採番（フォールバック用）
Private Function GenerateCaseNumberLocal(caseType As String) As String
    ' V2.0のロジックをそのまま使用
    ' ... (既存のGenerateCaseNumber関数のコード)
End Function


' 【重要】VBA-JSON ライブラリが必要
' https://github.com/VBA-tools/VBA-JSON
' JsonConverter.bas をインポートすること

 
5.6 死活監視システム（V2.1新規）
【概要】

Pythonスクリプトの無言の失敗を防ぐため、各スクリプトの実行状況を監視し、
異常があれば即座に管理者に通知する。


#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
死活監視スクリプト (healthcheck.py)

各スクリプトの実行状況を監視し、異常があればアラートを送信する。
"""

import json
from pathlib import Path
from datetime import datetime, timedelta
import logging
import smtplib
from email.mime.text import MIMEText


class HealthChecker:
    """ヘルスチェッククラス"""
    
    def __init__(self, config_path: str = "./config.json"):
        """初期化"""
        with open(config_path, 'r', encoding='utf-8') as f:
            self.config = json.load(f)
        
        self.log_dir = Path(self.config['paths']['log_dir'])
        
        self._setup_logging()
    
    def _setup_logging(self):
        """ロギング設定"""
        log_file = self.log_dir / f"healthcheck_{datetime.now().strftime('%Y%m%d')}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def check_script_execution(self, script_name: str, expected_time: str) -> dict:
        """
        スクリプトの実行状況をチェック
        
        Args:
            script_name (str): スクリプト名（distribute, integrate, sync等）
            expected_time (str): 期待実行時刻（HH:MM形式）
            
        Returns:
            dict: チェック結果
        """
        today = datetime.now().strftime('%Y%m%d')
        log_file = self.log_dir / f"{script_name}_{today}.log"
        
        result = {
            'script': script_name,
            'status': 'unknown',
            'errors': []
        }
        
        # ログファイルの存在チェック
        if not log_file.exists():
            result['status'] = 'error'
            result['errors'].append('ログファイルが存在しません')
            return result
        
        # ログファイルの内容チェック
        try:
            with open(log_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            if not lines:
                result['status'] = 'error'
                result['errors'].append('ログファイルが空です')
                return result
            
            # 最終行をチェック
            last_line = lines[-1].strip()
            
            # 成功キーワードの確認
            success_keywords = ['完了', '成功', 'completed', 'success']
            if any(keyword in last_line for keyword in success_keywords):
                result['status'] = 'ok'
            else:
                result['status'] = 'warning'
                result['errors'].append('正常終了メッセージが見つかりません')
            
            # エラーキーワードの確認
            error_keywords = ['error', 'エラー', 'failed', '失敗']
            for line in lines[-10:]:  # 最後の10行をチェック
                if any(keyword in line.lower() for keyword in error_keywords):
                    result['status'] = 'error'
                    result['errors'].append(f'エラーメッセージ検出: {line.strip()[:100]}')
            
            # 実行時刻のチェック
            first_line = lines[0].strip()
            if expected_time:
                # タイムスタンプを抽出
                # 例: "2025-11-13 08:30:15 - INFO - ..."
                try:
                    timestamp_str = first_line.split(' - ')[0]
                    log_time = datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S')
                    
                    expected_hour, expected_min = map(int, expected_time.split(':'))
                    expected_dt = log_time.replace(hour=expected_hour, minute=expected_min)
                    
                    # 期待時刻から±10分以内かチェック
                    time_diff = abs((log_time - expected_dt).total_seconds() / 60)
                    
                    if time_diff > 10:
                        result['errors'].append(
                            f'実行時刻が期待値からずれています（{time_diff:.0f}分）'
                        )
                        if result['status'] == 'ok':
                            result['status'] = 'warning'
                            
                except Exception as e:
                    self.logger.warning(f'時刻チェックエラー: {e}')
        
        except Exception as e:
            result['status'] = 'error'
            result['errors'].append(f'ログ読み込みエラー: {str(e)}')
        
        return result
    
    def check_heartbeat(self) -> dict:
        """
        ハートビートファイルをチェック
        
        Returns:
            dict: チェック結果
        """
        heartbeat_file = self.log_dir / "heartbeat.txt"
        
        if not heartbeat_file.exists():
            return {
                'status': 'error',
                'message': 'ハートビートファイルが存在しません'
            }
        
        try:
            with open(heartbeat_file, 'r') as f:
                lines = f.readlines()
            
            if not lines:
                return {
                    'status': 'error',
                    'message': 'ハートビートファイルが空です'
                }
            
            # タイムスタンプをチェック
            timestamp_line = lines[0].strip()
            last_heartbeat = datetime.fromisoformat(timestamp_line)
            
            # 1時間以上更新がなければ警告
            time_diff = datetime.now() - last_heartbeat
            
            if time_diff > timedelta(hours=1):
                return {
                    'status': 'warning',
                    'message': f'ハートビートが{time_diff}前から更新されていません'
                }
            
            return {
                'status': 'ok',
                'message': f'最終更新: {last_heartbeat.strftime("%Y-%m-%d %H:%M:%S")}'
            }
            
        except Exception as e:
            return {
                'status': 'error',
                'message': f'ハートビートチェックエラー: {str(e)}'
            }
    
    def send_alert(self, subject: str, body: str):
        """
        アラートメール送信
        
        Args:
            subject (str): 件名
            body (str): 本文
        """
        if not self.config.get('notification', {}).get('enabled', False):
            self.logger.info("メール通知が無効です")
            return
        
        try:
            msg = MIMEText(body, 'plain', 'utf-8')
            msg['Subject'] = f'[貿易DX] {subject}'
            msg['From'] = self.config['notification']['admin_email']
            msg['To'] = self.config['notification']['admin_email']
            
            smtp_server = self.config['notification']['smtp_server']
            smtp_port = self.config['notification']['smtp_port']
            
            with smtplib.SMTP(smtp_server, smtp_port) as server:
                server.send_message(msg)
            
            self.logger.info(f"アラートメール送信: {subject}")
            
        except Exception as e:
            self.logger.error(f"メール送信エラー: {e}")
    
    def run_all_checks(self) -> dict:
        """
        全チェックを実行
        
        Returns:
            dict: チェック結果サマリー
        """
        self.logger.info("=" * 60)
        self.logger.info("ヘルスチェック開始")
        self.logger.info("=" * 60)
        
        checks = {
            'distribute': self.check_script_execution('distribute', '08:30'),
            'integrate': self.check_script_execution('integrate', '17:30'),
            'sync': self.check_script_execution('sync', None),  # 30分ごとなので時刻指定なし
            'heartbeat': self.check_heartbeat()
        }
        
        # エラーまたは警告があればアラート
        errors = []
        warnings = []
        
        for check_name, result in checks.items():
            if result.get('status') == 'error':
                errors.append(f"{check_name}: {', '.join(result.get('errors', [result.get('message', '不明なエラー')]))}")
            elif result.get('status') == 'warning':
                warnings.append(f"{check_name}: {', '.join(result.get('errors', [result.get('message', '警告')]))}")
        
        # 結果表示
        if errors:
            self.logger.error(f"エラー検出: {len(errors)}件")
            for error in errors:
                self.logger.error(f"  - {error}")
            
            # アラートメール送信
            alert_body = "以下のエラーが検出されました:\n\n"
            alert_body += "\n".join(errors)
            self.send_alert("システムエラー検出", alert_body)
        
        if warnings:
            self.logger.warning(f"警告検出: {len(warnings)}件")
            for warning in warnings:
                self.logger.warning(f"  - {warning}")
        
        if not errors and not warnings:
            self.logger.info("全チェック正常")
        
        self.logger.info("=" * 60)
        
        return {
            'timestamp': datetime.now().isoformat(),
            'errors': len(errors),
            'warnings': len(warnings),
            'checks': checks
        }


def main():
    """メイン処理"""
    try:
        checker = HealthChecker("./config.json")
        result = checker.run_all_checks()
        
        exit(0 if result['errors'] == 0 else 1)
        
    except Exception as e:
        logging.error(f"致命的エラー: {e}")
        exit(2)


if __name__ == "__main__":
    main()

 
5.7 項目単位の競合解決機能（V2.1新規）
【概要】

V2.0では「最新タイムスタンプの行をまるごと採用」していたため、
同じ案件を複数人が異なる項目を更新した場合、片方の変更が消えるリスクがあった。
V2.1では項目単位で最新のものを採用することで、データロストを防ぐ。

5.7.1 問題の例

【V2.0の問題】

15:00 山田さん: 案件2025-EX-001の数量を更新
      案件番号: 2025-EX-001
      数量: 100 → 150
      最終更新: 2025/11/13 15:00

15:30 鈴木さん: 同じ案件の単価を更新
      案件番号: 2025-EX-001
      単価: 1000 → 1200
      最終更新: 2025/11/13 15:30

17:30 統合処理（V2.0のロジック）:
      「最新タイムスタンプ = 15:30」
      → 鈴木さんのデータをまるごと採用
      
結果:
  ✓ 単価: 1200（鈴木さんの更新が反映）
  ✗ 数量: 100（山田さんの更新が消える！）


【V2.1の改善】

17:30 統合処理（V2.1のロジック）:
      各項目ごとに最新のものを採用
      
      数量: 山田さんの更新（15:00）→ 150
      単価: 鈴木さんの更新（15:30）→ 1200
      
結果:
  ✓ 単価: 1200（鈴木さんの更新が反映）
  ✓ 数量: 150（山田さんの更新も反映）
  
両方の変更が保持される！

 
5.7.2 実装コード

# integrate_data.py に追加

def merge_with_field_level_resolution(master_df: pd.DataFrame, 
                                     user_dfs: list) -> pd.DataFrame:
    """
    項目単位で最新のデータをマージ
    
    Args:
        master_df (pd.DataFrame): マスターデータ
        user_dfs (list): 各ユーザーのデータフレームのリスト
        
    Returns:
        pd.DataFrame: マージ結果
    """
    # 競合ログ
    conflicts_log = []
    
    # 全データを結合（マスター + 全ユーザー）
    all_dfs = [master_df] + user_dfs if not master_df.empty else user_dfs
    
    # 案件番号でグループ化
    all_data = pd.concat(all_dfs, ignore_index=True)
    grouped = all_data.groupby('案件番号')
    
    merged_rows = []
    
    for case_no, group in grouped:
        if len(group) == 1:
            # 競合なし
            merged_rows.append(group.iloc[0].to_dict())
            continue
        
        # 競合あり - 項目単位でマージ
        merged_row = {}
        conflict_detected = False
        conflict_details = []
        
        # 基本項目
        merged_row['案件番号'] = case_no
        
        # 各項目について、最新のタイムスタンプを持つ値を採用
        for column in group.columns:
            if column in ['案件番号', '最終更新日時', '更新者']:
                continue
            
            # 各行の値とタイムスタンプを取得
            values = []
            for _, row in group.iterrows():
                value = row[column]
                timestamp = row.get('最終更新日時', pd.NaT)
                updater = row.get('更新者', '不明')
                
                values.append({
                    'value': value,
                    'timestamp': timestamp,
                    'updater': updater
                })
            
            # 空でない値のみを対象
            non_empty_values = [v for v in values if pd.notna(v['value']) and v['value'] != '']
            
            if not non_empty_values:
                merged_row[column] = ''
                continue
            
            # 最新のタイムスタンプを持つ値を採用
            latest = max(non_empty_values, key=lambda x: x['timestamp'] if pd.notna(x['timestamp']) else pd.Timestamp.min)
            merged_row[column] = latest['value']
            
            # 競合があるかチェック（複数の異なる値がある場合）
            unique_values = set([v['value'] for v in non_empty_values if pd.notna(v['value'])])
            if len(unique_values) > 1:
                conflict_detected = True
                conflict_details.append({
                    'column': column,
                    'values': non_empty_values,
                    'selected': latest
                })
        
        # 最終更新日時と更新者は最新のものを設定
        latest_row = group.loc[group['最終更新日時'].idxmax()]
        merged_row['最終更新日時'] = latest_row['最終更新日時']
        merged_row['更新者'] = latest_row['更新者']
        
        merged_rows.append(merged_row)
        
        # 競合をログに記録
        if conflict_detected:
            conflicts_log.append({
                'case_number': case_no,
                'conflicts': conflict_details,
                'timestamp': datetime.now().isoformat()
            })
            
            logger.warning(f"競合検出: {case_no}")
            for conflict in conflict_details:
                logger.warning(f"  項目: {conflict['column']}")
                for v in conflict['values']:
                    logger.warning(f"    - {v['updater']}: {v['value']} ({v['timestamp']})")
                logger.warning(f"  → 採用: {conflict['selected']['updater']}の値")
    
    # 競合ログを保存
    if conflicts_log:
        conflict_log_file = log_dir / f"conflicts_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(conflict_log_file, 'w', encoding='utf-8') as f:
            json.dump(conflicts_log, f, ensure_ascii=False, indent=2)
        
        logger.info(f"競合ログ保存: {conflict_log_file}")
    
    # DataFrameに変換
    merged_df = pd.DataFrame(merged_rows)
    
    return merged_df


# integrate_data.py の統合処理を更新

def integrate_all_data():
    """全データを統合（V2.1版）"""
    logger.info("=" * 60)
    logger.info("データ統合開始（V2.1 - 項目単位マージ）")
    logger.info("=" * 60)
    
    try:
        # マスター読み込み
        master_df = load_master_data()
        
        # 各ユーザーのデータ読み込み
        user_dfs = []
        for user in config['users']:
            user_df = load_user_data(user['name'])
            if not user_df.empty:
                user_df['更新者'] = user['name']  # 更新者を記録
                user_dfs.append(user_df)
        
        if not user_dfs:
            logger.info("統合対象データなし")
            return
        
        # 項目単位でマージ（V2.1の新機能）
        merged_df = merge_with_field_level_resolution(master_df, user_dfs)
        
        # マスターに保存
        save_master_data(merged_df)
        
        logger.info(f"統合完了: {len(merged_df)}件")
        logger.info("=" * 60)
        
    except Exception as e:
        logger.error(f"統合エラー: {e}")
        raise

 
5.8 ファイルロック検知とリトライ機構（V2.1新規）
【概要】

統合処理中にユーザーがファイルを開いている場合、統合が失敗する。
V2.1ではファイルロックを検知し、自動的にリトライする機構を実装。


# integrate_data.py に追加

import time
from pathlib import Path

def check_file_locked(file_path: Path, timeout: int = 5) -> bool:
    """
    ファイルがロックされているかチェック
    
    Args:
        file_path (Path): チェック対象ファイル
        timeout (int): タイムアウト秒数
        
    Returns:
        bool: ロックされている場合True
    """
    try:
        # ファイルを排他モードで開こうとする
        with open(file_path, 'r+b') as f:
            pass
        return False  # ロックされていない
        
    except (IOError, PermissionError):
        return True  # ロックされている


def integrate_with_retry(max_retry: int = 3, retry_interval: int = 60):
    """
    リトライ機能付き統合処理
    
    Args:
        max_retry (int): 最大リトライ回数
        retry_interval (int): リトライ間隔（秒）
    """
    
    for attempt in range(max_retry):
        logger.info(f"統合試行 {attempt + 1}/{max_retry}")
        
        # ファイルロックチェック
        locked_files = []
        
        for user in config['users']:
            user_file = work_dir / f"案件管理台帳_{user['name']}.xlsm"
            
            if not user_file.exists():
                continue
            
            if check_file_locked(user_file):
                locked_files.append(user['name'])
        
        if not locked_files:
            # 全てのファイルがロックされていない
            logger.info("全ファイルがアクセス可能")
            
            # 統合実行
            try:
                integrate_all_data()
                logger.info("統合成功")
                return True
                
            except Exception as e:
                logger.error(f"統合エラー: {e}")
                if attempt < max_retry - 1:
                    logger.info(f"{retry_interval}秒後にリトライ...")
                    time.sleep(retry_interval)
                else:
                    logger.error("最大リトライ回数に達しました")
                    send_alert_email("統合失敗", f"エラー: {e}")
                    return False
        
        else:
            # 一部のファイルがロック中
            logger.warning(f"ファイルがロック中: {', '.join(locked_files)}")
            
            if attempt < max_retry - 1:
                logger.info(f"{retry_interval}秒後にリトライ...")
                time.sleep(retry_interval)
            else:
                # 最終リトライでも失敗
                logger.error(f"統合失敗: {', '.join(locked_files)}のファイルがロック中")
                
                # アラートメール送信
                alert_message = f"""
統合処理が失敗しました。

ロック中のファイル:
{chr(10).join([f"  - {user}" for user in locked_files])}

対処方法:
1. 該当ユーザーにファイルを閉じてもらう
2. 手動で統合スクリプトを再実行する
"""
                send_alert_email("統合失敗（ファイルロック）", alert_message)
                return False
    
    return False


def send_alert_email(subject: str, message: str):
    """アラートメール送信"""
    if not config.get('notification', {}).get('enabled', False):
        logger.info("メール通知が無効です")
        return
    
    try:
        import smtplib
        from email.mime.text import MIMEText
        
        msg = MIMEText(message, 'plain', 'utf-8')
        msg['Subject'] = f'[貿易DX] {subject}'
        msg['From'] = config['notification']['admin_email']
        msg['To'] = config['notification']['admin_email']
        
        with smtplib.SMTP(config['notification']['smtp_server'], 
                         config['notification']['smtp_port']) as server:
            server.send_message(msg)
        
        logger.info(f"アラートメール送信: {subject}")
        
    except Exception as e:
        logger.error(f"メール送信エラー: {e}")


# メイン処理を更新
def main():
    """メイン処理（V2.1版）"""
    try:
        # リトライ機能付き統合
        success = integrate_with_retry(
            max_retry=3,
            retry_interval=60  # 1分間隔
        )
        
        exit(0 if success else 1)
        
    except Exception as e:
        logger.error(f"致命的エラー: {e}")
        send_alert_email("致命的エラー", str(e))
        exit(2)

 
5.9 バックアップ世代管理の改善（V2.1新規）
【概要】

V2.0では全世代を保持していたが、ディスク容量を圧迫する可能性がある。
V2.1では30日分のみ保持し、古いバックアップは自動削除する。


# backup_manager.py（新規）

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
バックアップ管理スクリプト
"""

import shutil
from pathlib import Path
from datetime import datetime, timedelta
import json
import logging


class BackupManager:
    """バックアップ管理クラス"""
    
    def __init__(self, config_path: str = "./config.json"):
        """初期化"""
        with open(config_path, 'r', encoding='utf-8') as f:
            self.config = json.load(f)
        
        self.master_dir = Path(self.config['paths']['master_dir'])
        self.backup_dir = Path(self.config['paths']['backup_dir'])
        self.log_dir = Path(self.config['paths']['log_dir'])
        
        # バックアップ保持日数（デフォルト30日）
        self.retention_days = self.config.get('backup', {}).get('retention_days', 30)
        
        self._setup_logging()
    
    def _setup_logging(self):
        """ロギング設定"""
        log_file = self.log_dir / f"backup_{datetime.now().strftime('%Y%m%d')}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def create_backup(self) -> Path:
        """
        バックアップを作成
        
        Returns:
            Path: バックアップファイルのパス
        """
        master_file = self.master_dir / "案件管理台帳_マスター.xlsm"
        
        if not master_file.exists():
            self.logger.warning("マスターファイルが存在しません")
            return None
        
        # バックアップファイル名
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_file = self.backup_dir / f"案件管理台帳_マスター_{timestamp}.xlsm"
        
        # コピー
        shutil.copy2(master_file, backup_file)
        
        self.logger.info(f"バックアップ作成: {backup_file.name}")
        
        return backup_file
    
    def cleanup_old_backups(self):
        """古いバックアップを削除"""
        self.logger.info(f"バックアップクリーンアップ開始（保持日数: {self.retention_days}日）")
        
        # カットオフ日時
        cutoff_date = datetime.now() - timedelta(days=self.retention_days)
        
        # バックアップファイル一覧
        backup_files = sorted(self.backup_dir.glob("案件管理台帳_マスター_*.xlsm"))
        
        deleted_count = 0
        
        for backup_file in backup_files:
            # ファイルの更新日時を取得
            file_mtime = datetime.fromtimestamp(backup_file.stat().st_mtime)
            
            if file_mtime < cutoff_date:
                # 古いバックアップを削除
                backup_file.unlink()
                self.logger.info(f"削除: {backup_file.name} ({file_mtime.strftime('%Y-%m-%d')})")
                deleted_count += 1
        
        if deleted_count > 0:
            self.logger.info(f"クリーンアップ完了: {deleted_count}件削除")
        else:
            self.logger.info("削除対象のバックアップなし")
    
    def get_backup_list(self, limit: int = 10) -> list:
        """
        バックアップ一覧を取得
        
        Args:
            limit (int): 取得件数
            
        Returns:
            list: バックアップファイル情報のリスト
        """
        backup_files = sorted(
            self.backup_dir.glob("案件管理台帳_マスター_*.xlsm"),
            key=lambda x: x.stat().st_mtime,
            reverse=True
        )[:limit]
        
        result = []
        
        for backup_file in backup_files:
            stat = backup_file.stat()
            result.append({
                'filename': backup_file.name,
                'path': str(backup_file),
                'size': stat.st_size,
                'mtime': datetime.fromtimestamp(stat.st_mtime).isoformat()
            })
        
        return result
    
    def restore_from_backup(self, backup_file: Path) -> bool:
        """
        バックアップから復元
        
        Args:
            backup_file (Path): バックアップファイルのパス
            
        Returns:
            bool: 成功した場合True
        """
        if not backup_file.exists():
            self.logger.error(f"バックアップファイルが存在しません: {backup_file}")
            return False
        
        master_file = self.master_dir / "案件管理台帳_マスター.xlsm"
        
        # 現在のマスターを退避
        if master_file.exists():
            emergency_backup = self.master_dir / f"案件管理台帳_マスター_復元前_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsm"
            shutil.copy2(master_file, emergency_backup)
            self.logger.info(f"現在のマスターを退避: {emergency_backup.name}")
        
        # バックアップから復元
        shutil.copy2(backup_file, master_file)
        
        self.logger.info(f"復元完了: {backup_file.name} → {master_file.name}")
        
        return True


def main():
    """メイン処理"""
    try:
        manager = BackupManager("./config.json")
        
        # バックアップ作成
        manager.create_backup()
        
        # 古いバックアップをクリーンアップ
        manager.cleanup_old_backups()
        
        exit(0)
        
    except Exception as e:
        logging.error(f"致命的エラー: {e}")
        exit(2)


if __name__ == "__main__":
    main()

 
6. 設定ファイル（V2.1版）
【概要】

V2.1で追加された機能に対応するため、config.jsonを拡張。
案件番号サーバーの設定、バックアップ保持日数、通知設定などを追加。

【config.json（V2.1版）】

{
  "version": "2.1",
  "paths": {
    "master_dir": "Z:/共有/貿易DX/master",
    "work_dir": "Z:/共有/貿易DX/work",
    "backup_dir": "Z:/共有/貿易DX/backup",
    "log_dir": "Z:/共有/貿易DX/logs",
    "scripts_dir": "Z:/共有/貿易DX/scripts"
  },
  
  "users": [
    {"name": "山田", "email": "yamada@example.com"},
    {"name": "鈴木", "email": "suzuki@example.com"},
    {"name": "佐藤", "email": "sato@example.com"},
    {"name": "田中", "email": "tanaka@example.com"}
  ],
  
  "case_number_server": {
    "enabled": true,
    "host": "0.0.0.0",
    "port": 8080,
    "url": "http://localhost:8080",
    "fallback_to_local": true
  },
  
  "sync": {
    "enabled": true,
    "interval_minutes": 30,
    "retry_on_lock": true,
    "max_retry": 3,
    "retry_interval_seconds": 60
  },
  
  "backup": {
    "enabled": true,
    "retention_days": 30,
    "auto_cleanup": true,
    "create_before_integrate": true
  },
  
  "health_check": {
    "enabled": true,
    "check_times": ["08:00", "18:00"],
    "alert_on_error": true,
    "alert_on_warning": false
  },
  
  "notification": {
    "enabled": true,
    "admin_email": "admin@example.com",
    "smtp_server": "smtp.example.com",
    "smtp_port": 587,
    "smtp_user": "notifications@example.com",
    "smtp_password": "password",
    "alert_types": {
      "integration_failure": true,
      "file_locked": true,
      "script_error": true,
      "conflict_detected": false
    }
  },
  
  "conflict_resolution": {
    "method": "field_level",
    "log_conflicts": true,
    "notify_conflicts": false
  },
  
  "logging": {
    "level": "INFO",
    "format": "%(asctime)s - %(levelname)s - %(message)s",
    "retention_days": 90
  }
}

 
7. 運用マニュアル（V2.1版）
7.1 初期セットアップ

【1. 環境構築】

1.1 Python環境のインストール
   - Python 3.9以降をインストール
   - 必要なライブラリをインストール:
     pip install pandas openpyxl --break-system-packages

1.2 共有フォルダの作成
   Z:\共有\貿易DX\
   ├ master\          # マスターファイル
   ├ work\            # 個人ファイル
   ├ backup\          # バックアップ
   ├ logs\            # ログファイル
   └ scripts\         # Pythonスクリプト

1.3 スクリプトの配置
   以下のスクリプトをscripts\フォルダに配置:
   - config.json
   - distribute_files.py
   - integrate_data.py
   - incremental_sync.py         # V2.1新規
   - case_number_server.py        # V2.1新規
   - healthcheck.py               # V2.1新規
   - backup_manager.py            # V2.1新規

1.4 マスターファイルの配置
   案件管理台帳_マスター.xlsm をmaster\フォルダに配置


【2. 案件番号サーバーの起動】

2.1 Windowsサービスとして登録（推奨）
   
   scripts\フォルダに以下のバッチファイルを作成:
   
   start_case_number_server.bat:
   ---
   @echo off
   cd /d Z:\共有\貿易DX\scripts
   python case_number_server.py
   ---
   
2.2 タスクスケジューラで自動起動を設定
   
   タスク名: 貿易DX_案件番号サーバー
   トリガー: システム起動時
   操作: start_case_number_server.bat を実行
   
2.3 起動確認
   
   ブラウザで http://localhost:8080/health にアクセス
   {"status": "ok", ...} が表示されればOK


【3. タスクスケジューラの設定】

3.1 朝の配布（8:30）
   タスク名: 貿易DX_朝の配布
   トリガー: 毎日 8:30
   操作: python Z:\共有\貿易DX\scripts\distribute_files.py

3.2 30分ごとの軽量同期（V2.1新規）
   タスク名: 貿易DX_差分同期
   トリガー: 毎日 0:00、繰り返し間隔30分、継続時間1日
   操作: python Z:\共有\貿易DX\scripts\incremental_sync.py

3.3 夕方の統合（17:30）
   タスク名: 貿易DX_夕方の統合
   トリガー: 毎日 17:30
   操作: python Z:\共有\貿易DX\scripts\integrate_data.py

3.4 最終統合（19:00）- V2.1新規
   タスク名: 貿易DX_最終統合
   トリガー: 毎日 19:00
   操作: python Z:\共有\貿易DX\scripts\integrate_data.py

3.5 バックアップ（17:35）
   タスク名: 貿易DX_バックアップ
   トリガー: 毎日 17:35
   操作: python Z:\共有\貿易DX\scripts\backup_manager.py

3.6 ヘルスチェック（8:00, 18:00）- V2.1新規
   タスク名: 貿易DX_ヘルスチェック
   トリガー: 毎日 8:00 と 18:00
   操作: python Z:\共有\貿易DX\scripts\healthcheck.py


【4. ユーザー教育】

4.1 基本ルール
   ✓ 朝8:30以降にファイルを開く
   ✓ 17:00までに作業を終える（できれば）
   ✓ 作業中はこまめに保存する
   ✓ 退社時は必ずファイルを閉じる

4.2 案件番号の生成
   ✓ [案件番号生成]ボタンをクリック
   ✓ 自動的にサーバーから取得される
   ✓ 重複の心配なし

4.3 トラブル時の対応
   ✓ 管理者に連絡
   ✓ ファイルを開いたまま放置しない
   ✓ ローカルにコピーしない

 
7.2 日常運用

【管理者の日次タスク】

【朝（8:00-9:00）】

□ ヘルスチェック結果の確認
  - logs\healthcheck_YYYYMMDD.log を確認
  - エラーがあれば対処

□ 配布ログの確認
  - logs\distribute_YYYYMMDD.log を確認
  - 全ユーザーに正常配布されたか確認

□ メールボックスの確認
  - アラートメールが届いていないか確認


【夕方（17:30-18:00）】

□ 統合ログの確認
  - logs\integrate_YYYYMMDD.log を確認
  - エラーがあれば対処

□ 競合ログの確認（あれば）
  - logs\conflicts_*.json を確認
  - 重要な競合があれば関係者に確認

□ バックアップの確認
  - backup\フォルダに最新のバックアップがあるか確認


【週次タスク（金曜日）】

□ ログファイルの確認
  - 1週間分のログをレビュー
  - 頻発するエラーや警告がないか確認

□ バックアップの動作確認
  - backup\フォルダのファイル数を確認
  - 古いバックアップが自動削除されているか確認

□ ディスク容量の確認
  - 共有フォルダの空き容量を確認
  - 必要に応じてクリーンアップ


【月次タスク（月末）】

□ 全体レビュー
  - 1ヶ月の統合成功率を確認
  - ユーザーからのフィードバック収集

□ パフォーマンスチェック
  - 統合処理時間の推移を確認
  - データ量の増加を確認

□ バックアップテスト
  - 実際にバックアップから復元できるかテスト

 
7.3 トラブルシューティング
症状	原因	対処方法
統合が失敗する	ユーザーがファイルを開いている	1. 該当ユーザーにファイルを閉じてもらう
2. 1時間後に自動リトライされる
3. 急ぐ場合は手動で再実行
データが消えた	統合タイミングの問題
または保存忘れ	1. backup\フォルダから復元
2. 最新のバックアップを確認
3. 必要に応じて手動マージ
案件番号が重複	サーバーが停止している	1. サーバーの起動を確認
2. start_case_number_server.bat を実行
3. 重複番号を手動で修正
アラートメールが届かない	SMTP設定が間違っている	1. config.jsonのnotification設定を確認
2. SMTPサーバーの接続を確認
3. テストメールを送信
30分同期が動かない	タスクスケジューラの設定ミス	1. タスクスケジューラを開く
2. 「貿易DX_差分同期」を確認
3. トリガー設定を確認
ファイルが開けない	マクロのセキュリティ設定	1. Excelのセキュリティ設定を確認
2. マクロを有効化
3. 信頼できる場所に追加
処理が遅い	データ量が多すぎる	1. 古いデータをアーカイブ
2. 年度ごとにファイル分割を検討
3. サーバースペックの見直し
 
7.4 緊急時の対応

【シナリオ1: 全データが破損した】

緊急度: 🔴 最高

対処手順:
1. 全ユーザーに作業停止を指示
2. backup\フォルダから最新のバックアップを確認
3. バックアップから復元:
   python scripts/backup_manager.py --restore backup/案件管理台帳_マスター_YYYYMMDD_HHMMSS.xlsm
4. 復元後、整合性をチェック
5. ユーザーに作業再開を指示
6. 原因究明と再発防止策の検討


【シナリオ2: サーバーがダウンした】

緊急度: 🟡 中

対処手順:
1. サーバーの状態を確認
2. 案件番号サーバーを再起動:
   scripts/start_case_number_server.bat
3. 起動確認: http://localhost:8080/health
4. ユーザーに状況を通知
5. ローカル採番でも作業は継続可能（重複リスクあり）


【シナリオ3: 管理者が不在時にトラブル】

緊急度: 🟠 高

対処手順:
1. 代理管理者を事前に指定しておく
2. このマニュアルと config.json の場所を共有
3. 基本的なトラブルシューティングを教育
4. 緊急連絡先を明記
5. 最悪の場合は「作業停止」を指示


【緊急連絡先】

システム管理者:
  氏名: ___________
  内線: ___________
  携帯: ___________
  メール: ___________

代理管理者:
  氏名: ___________
  内線: ___________
  携帯: ___________
  メール: ___________

ITベンダー:
  会社名: ___________
  担当者: ___________
  電話: ___________
  メール: ___________

 
8. 実装計画（V2.1）
【概要】

V2.0からV2.1への移行は段階的に実施する。
既存のV2.0システムを稼働させながら、V2.1の機能を順次追加していく方式。

8.1 実装スケジュール
フェーズ	作業内容	期間	担当	成果物
準備	V2.0の安定稼働確認
運用課題の洗い出し	3日	開発チーム	課題一覧
1週目	案件番号サーバー開発
単体テスト	3日	開発者A	case_number_server.py
1週目	30分同期機能開発
単体テスト	2日	開発者B	incremental_sync.py
2週目	競合解決ロジック開発
integrate_data.py改修	3日	開発者A	改修版スクリプト
2週目	ファイルロック検知
リトライ機構実装	2日	開発者B	改修版スクリプト
3週目	死活監視システム開発	2日	開発者A	healthcheck.py
3週目	バックアップ管理改善	1日	開発者B	backup_manager.py
3週目	結合テスト	2日	全員	テスト結果報告書
4週目	運用テスト（本番環境）	3日	全員+ユーザー	運用確認書
4週目	ドキュメント整備
ユーザー教育	2日	全員	運用マニュアル
 
8.2 段階的移行計画

【フェーズ1: 案件番号サーバーの導入（1週目）】

目的: 案件番号衝突を完全に防止

手順:
1. 案件番号サーバーを開発
2. 開発環境でテスト
3. 本番環境にサーバーを起動
4. VBAを改修（サーバー呼び出し + ローカル採番フォールバック）
5. 1名のユーザーでパイロットテスト
6. 問題なければ全ユーザーに展開

リスク:
- サーバーダウン時のフォールバック動作を確認
- ネットワーク遅延の影響を確認

ロールバック:
- VBAを元のバージョンに戻す（ローカル採番のみ）


【フェーズ2: 30分同期の導入（1-2週目）】

目的: データロストリスクの削減

手順:
1. incremental_sync.py を開発
2. 個人ファイルに「同期済みフラグ」列を追加
3. タスクスケジューラに30分ごとの実行を設定
4. 1週間の監視期間
5. 問題なければ本格運用

リスク:
- 30分ごとの処理負荷
- 同期フラグの管理ミス

ロールバック:
- タスクスケジューラから30分同期を削除
- 夕方の統合のみに戻す


【フェーズ3: 競合解決とファイルロックの改善（2-3週目）】

目的: データロストの完全防止

手順:
1. integrate_data.py を改修
2. 項目単位のマージロジックを実装
3. ファイルロック検知とリトライを実装
4. テスト環境で十分にテスト
5. 本番環境に展開

リスク:
- マージロジックのバグ
- リトライ処理の無限ループ

ロールバック:
- integrate_data.py を V2.0 版に戻す


【フェーズ4: 監視システムの導入（3週目）】

目的: 異常の早期検知

手順:
1. healthcheck.py を開発
2. メール通知の設定
3. タスクスケジューラに朝夕の実行を設定
4. 監視メールの受信確認
5. アラート対応手順の確立

リスク:
- 誤アラートの頻発
- メール通知の遅延

ロールバック:
- タスクスケジューラから削除（運用に影響なし）


【フェーズ5: 総合テストと本格運用（4週目）】

目的: 全機能の統合確認

手順:
1. 全機能を有効化した状態で1週間運用
2. ユーザーからのフィードバック収集
3. 不具合があれば修正
4. 運用マニュアルの最終化
5. 本格運用開始の宣言

 
8.3 コスト見積もり
項目	工数（人日）	単価（円/日）	金額（円）
案件番号サーバー開発	3	80,000	240,000
30分同期機能開発	2	80,000	160,000
競合解決ロジック開発	3	80,000	240,000
ファイルロック・リトライ開発	2	80,000	160,000
死活監視システム開発	2	80,000	160,000
バックアップ管理改善	1	80,000	80,000
テスト・デバッグ	3	80,000	240,000
ドキュメント整備	2	60,000	120,000
合計	18	-	1,400,000

※ 社内開発の場合は人件費のみ。外注の場合は上記金額 + 諸経費10%程度。
※ V2.0からの差分開発のため、ゼロから開発する場合より大幅に安価。
 
8.4 リスク管理
リスク	発生確率	影響度	対策	担当
開発遅延	中	中	バッファを2週間確保
優先度の低い機能は延期	PM
不具合の混入	中	高	十分なテスト期間を確保
V2.0へのロールバック準備	開発リーダー
ユーザーの混乱	低	中	事前説明会の実施
マニュアルの充実	PM
サーバーの不安定	低	高	フォールバック機構の実装
監視体制の強化	インフラ担当
データロスト	低	最高	バックアップの徹底
復元手順の確立	全員
性能劣化	中	中	事前の性能テスト
チューニング期間の確保	開発担当
予算超過	低	中	段階的実装による調整
必須機能の優先実装	PM
 
9. 付録
9.1 V2.0とV2.1の機能比較
機能	V2.0	V2.1
ファイル分割	○	○
朝の配布	○	○
夕方の統合	○（1回）	○（2回：17:30, 19:00）
30分ごとの同期	×	○（NEW）
案件番号サーバー	×	○（NEW）
案件番号衝突防止	△（頻発）	○（完全防止）
競合解決	△（行単位）	○（項目単位）
ファイルロック対応	×	○（リトライ機構）
死活監視	×	○（自動アラート）
バックアップ管理	○	○（自動削除機能追加）
 
9.2 よくある質問（FAQ）

Q1: V2.0からV2.1への移行は必須ですか？
A1: 必須ではありません。V2.0でも基本的な運用は可能です。
    ただし、実運用で以下の問題が頻発する場合はV2.1への移行を推奨します：
    - 案件番号の衝突が月1回以上発生
    - 統合失敗が月2回以上発生
    - データロストが発生


Q2: V2.1の開発期間はどのくらいですか？
A2: 約4週間（20営業日）です。
    ただし、これは開発のみの期間で、実際の運用開始までには
    テスト期間やユーザー教育期間を含めて6週間程度を見込んでください。


Q3: 既存のV2.0データはV2.1でも使えますか？
A3: はい、完全に互換性があります。
    マスターファイルや個人ファイルの構造は変わらないため、
    そのまま継続して使用できます。


Q4: V2.1に移行する際のダウンタイムは？
A4: 基本的にダウンタイムはありません。
    段階的に機能を追加していく方式のため、通常業務を継続しながら移行できます。
    ただし、最終的な切り替え時に1-2時間程度の作業停止をお願いする可能性があります。


Q5: 社内に開発者がいない場合は？
A5: 以下の選択肢があります：
    1. ITベンダーに開発を委託（費用: 約150-200万円）
    2. V2.0のまま運用し、問題が発生したら対応
    3. 長期的にGoogleスプレッドシートへの移行を検討


Q6: 30分同期は本当に必要ですか？
A6: ユーザー数と更新頻度によります：
    - ユーザー5人以下、更新頻度低 → 不要かも
    - ユーザー10人以上、更新頻度高 → 推奨
    - リアルタイム性が重要 → 必須


Q7: サーバーが必要と聞きましたが、どんなサーバーですか？
A7: 非常に軽量なHTTPサーバーです：
    - 既存のファイルサーバーで動作
    - メモリ: 100MB以下
    - CPU: ほぼ使用しない
    - 専用サーバーは不要


Q8: トラブル時のサポートは？
A8: 本ドキュメントの「7.3 トラブルシューティング」を参照してください。
    また、開発ベンダーとの保守契約も検討してください。


Q9: 他社の成功事例はありますか？
A9: 類似のシステムは多数の企業で稼働しています。
    ただし、貿易業界特有の要件もあるため、カスタマイズが必要です。


Q10: 将来的にクラウド化の予定は？
A10: V2.1はオンプレミス版ですが、将来的にGoogleスプレッドシートや
     クラウドデータベースへの移行を検討する余地があります。
     その際、本システムで蓄積したノウハウが活かせます。

 
9.3 用語集
用語	説明
マスターファイル	すべてのユーザーのデータが統合された中央管理ファイル
個人ファイル	各ユーザーが作業に使用する個別のファイル
配布	マスターファイルから個人ファイルへデータをコピーする処理
統合	各個人ファイルからマスターファイルへデータをマージする処理
差分同期	変更があったデータのみを同期する軽量な処理
案件番号サーバー	一意な案件番号を生成・管理するHTTPサーバー
競合	同じデータを複数人が同時に更新した状態
項目単位マージ	競合時に行ごとではなく項目ごとに最新データを採用する方式
ファイルロック	ファイルが開かれていて他のプロセスがアクセスできない状態
リトライ	処理が失敗した際に自動的に再試行する機構
ヘルスチェック	システムの正常性を定期的に確認する処理
ハートビート	プロセスが正常動作中であることを示す定期的な信号
ロールバック	問題発生時に以前のバージョンに戻すこと
フォールバック	メイン処理が失敗した際の代替処理
バックアップ世代管理	複数世代のバックアップを保持し古いものを自動削除する機能
 
10. 承認
役割	氏名	承認日
作成者		
レビュー者		
承認者（PM）		
承認者（部門長）		

以上
